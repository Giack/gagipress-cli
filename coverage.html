
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gagipress/gagipress-cli/cmd/auth/auth.go (0.0%)</option>
				
				<option value="file1">github.com/gagipress/gagipress-cli/cmd/auth/instagram.go (0.0%)</option>
				
				<option value="file2">github.com/gagipress/gagipress-cli/cmd/auth/openai.go (0.0%)</option>
				
				<option value="file3">github.com/gagipress/gagipress-cli/cmd/auth/tiktok.go (0.0%)</option>
				
				<option value="file4">github.com/gagipress/gagipress-cli/cmd/books/add.go (0.0%)</option>
				
				<option value="file5">github.com/gagipress/gagipress-cli/cmd/books/books.go (0.0%)</option>
				
				<option value="file6">github.com/gagipress/gagipress-cli/cmd/books/delete.go (0.0%)</option>
				
				<option value="file7">github.com/gagipress/gagipress-cli/cmd/books/edit.go (0.0%)</option>
				
				<option value="file8">github.com/gagipress/gagipress-cli/cmd/books/list.go (0.0%)</option>
				
				<option value="file9">github.com/gagipress/gagipress-cli/cmd/books/sales.go (0.0%)</option>
				
				<option value="file10">github.com/gagipress/gagipress-cli/cmd/calendar/approve.go (0.0%)</option>
				
				<option value="file11">github.com/gagipress/gagipress-cli/cmd/calendar/calendar.go (0.0%)</option>
				
				<option value="file12">github.com/gagipress/gagipress-cli/cmd/calendar/plan.go (0.0%)</option>
				
				<option value="file13">github.com/gagipress/gagipress-cli/cmd/calendar/show.go (0.0%)</option>
				
				<option value="file14">github.com/gagipress/gagipress-cli/cmd/db/db.go (0.0%)</option>
				
				<option value="file15">github.com/gagipress/gagipress-cli/cmd/db/migrate.go (0.0%)</option>
				
				<option value="file16">github.com/gagipress/gagipress-cli/cmd/db/status.go (0.0%)</option>
				
				<option value="file17">github.com/gagipress/gagipress-cli/cmd/generate/generate.go (0.0%)</option>
				
				<option value="file18">github.com/gagipress/gagipress-cli/cmd/generate/ideas.go (0.0%)</option>
				
				<option value="file19">github.com/gagipress/gagipress-cli/cmd/generate/script.go (0.0%)</option>
				
				<option value="file20">github.com/gagipress/gagipress-cli/cmd/ideas/approve.go (0.0%)</option>
				
				<option value="file21">github.com/gagipress/gagipress-cli/cmd/ideas/ideas.go (0.0%)</option>
				
				<option value="file22">github.com/gagipress/gagipress-cli/cmd/ideas/list.go (0.0%)</option>
				
				<option value="file23">github.com/gagipress/gagipress-cli/cmd/ideas/reject.go (0.0%)</option>
				
				<option value="file24">github.com/gagipress/gagipress-cli/cmd/init.go (0.0%)</option>
				
				<option value="file25">github.com/gagipress/gagipress-cli/cmd/root.go (0.0%)</option>
				
				<option value="file26">github.com/gagipress/gagipress-cli/cmd/stats/correlate.go (0.0%)</option>
				
				<option value="file27">github.com/gagipress/gagipress-cli/cmd/stats/show.go (0.0%)</option>
				
				<option value="file28">github.com/gagipress/gagipress-cli/cmd/stats/stats.go (0.0%)</option>
				
				<option value="file29">github.com/gagipress/gagipress-cli/cmd/test/gemini.go (0.0%)</option>
				
				<option value="file30">github.com/gagipress/gagipress-cli/cmd/test/test.go (0.0%)</option>
				
				<option value="file31">github.com/gagipress/gagipress-cli/cmd/version.go (0.0%)</option>
				
				<option value="file32">github.com/gagipress/gagipress-cli/internal/ai/gemini.go (0.0%)</option>
				
				<option value="file33">github.com/gagipress/gagipress-cli/internal/ai/openai.go (0.0%)</option>
				
				<option value="file34">github.com/gagipress/gagipress-cli/internal/config/config.go (0.0%)</option>
				
				<option value="file35">github.com/gagipress/gagipress-cli/internal/errors/errors.go (100.0%)</option>
				
				<option value="file36">github.com/gagipress/gagipress-cli/internal/errors/retry.go (94.1%)</option>
				
				<option value="file37">github.com/gagipress/gagipress-cli/internal/generator/ideas.go (0.0%)</option>
				
				<option value="file38">github.com/gagipress/gagipress-cli/internal/generator/scripts.go (0.0%)</option>
				
				<option value="file39">github.com/gagipress/gagipress-cli/internal/models/book.go (83.3%)</option>
				
				<option value="file40">github.com/gagipress/gagipress-cli/internal/models/content.go (36.4%)</option>
				
				<option value="file41">github.com/gagipress/gagipress-cli/internal/models/metrics.go (44.4%)</option>
				
				<option value="file42">github.com/gagipress/gagipress-cli/internal/models/sales.go (0.0%)</option>
				
				<option value="file43">github.com/gagipress/gagipress-cli/internal/parser/kdp.go (96.9%)</option>
				
				<option value="file44">github.com/gagipress/gagipress-cli/internal/prompts/templates.go (0.0%)</option>
				
				<option value="file45">github.com/gagipress/gagipress-cli/internal/repository/books.go (0.0%)</option>
				
				<option value="file46">github.com/gagipress/gagipress-cli/internal/repository/calendar.go (0.0%)</option>
				
				<option value="file47">github.com/gagipress/gagipress-cli/internal/repository/content.go (0.0%)</option>
				
				<option value="file48">github.com/gagipress/gagipress-cli/internal/repository/metrics.go (0.0%)</option>
				
				<option value="file49">github.com/gagipress/gagipress-cli/internal/repository/sales.go (0.0%)</option>
				
				<option value="file50">github.com/gagipress/gagipress-cli/internal/scheduler/optimizer.go (96.6%)</option>
				
				<option value="file51">github.com/gagipress/gagipress-cli/internal/scheduler/planner.go (9.7%)</option>
				
				<option value="file52">github.com/gagipress/gagipress-cli/internal/social/instagram.go (0.0%)</option>
				
				<option value="file53">github.com/gagipress/gagipress-cli/internal/social/tiktok.go (0.0%)</option>
				
				<option value="file54">github.com/gagipress/gagipress-cli/internal/supabase/client.go (0.0%)</option>
				
				<option value="file55">github.com/gagipress/gagipress-cli/internal/supabase/migrate.go (0.0%)</option>
				
				<option value="file56">github.com/gagipress/gagipress-cli/internal/testutil/helpers.go (0.0%)</option>
				
				<option value="file57">github.com/gagipress/gagipress-cli/internal/ui/spinner.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "github.com/spf13/cobra"
)

// AuthCmd represents the auth command group
var AuthCmd = &amp;cobra.Command{
        Use:   "auth",
        Short: "Test API authentication and connections",
        Long: `Test authentication and connectivity for various API integrations:
  - OpenAI API
  - Instagram Graph API (requires OAuth)
  - TikTok API (requires OAuth)`,
}

func init() <span class="cov0" title="0">{
        AuthCmd.AddCommand(openaiCmd)
        AuthCmd.AddCommand(instagramCmd)
        AuthCmd.AddCommand(tiktokCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/social"
        "github.com/spf13/cobra"
)

var instagramCmd = &amp;cobra.Command{
        Use:   "instagram",
        Short: "Test Instagram API connection",
        Long:  `Test Instagram Graph API authentication and connection.`,
        RunE:  runInstagramAuth,
}

func runInstagramAuth(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üì∏ Testing Instagram API connection...")

        // Create Instagram client
        client := social.NewInstagramClient(&amp;cfg.Instagram)

        // Test connection
        fmt.Print("   Testing connection... ")
        if err := client.TestConnection(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                fmt.Println("\n‚ö†Ô∏è  Instagram OAuth flow not yet implemented.")
                fmt.Println("   This will be available in Week 3 of implementation.")
                fmt.Println("   Required steps:")
                fmt.Println("   1. Create Facebook App")
                fmt.Println("   2. Connect Instagram Business Account")
                fmt.Println("   3. Complete OAuth flow")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Println("\n‚úÖ Instagram API is configured correctly!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/ai"
        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/spf13/cobra"
)

var openaiCmd = &amp;cobra.Command{
        Use:   "openai",
        Short: "Test OpenAI API connection",
        Long:  `Test OpenAI API authentication and connection by sending a simple request.`,
        RunE:  runOpenAIAuth,
}

func runOpenAIAuth(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Check if API key is configured
        <span class="cov0" title="0">if cfg.OpenAI.APIKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OpenAI API key not configured. Run 'gagipress init' first")
        }</span>

        <span class="cov0" title="0">fmt.Println("üîë Testing OpenAI API connection...")
        fmt.Printf("   Model: %s\n", cfg.OpenAI.Model)

        // Create OpenAI client
        client := ai.NewOpenAIClient(&amp;cfg.OpenAI)

        // Test connection
        fmt.Print("   Sending test request... ")
        if err := client.TestConnection(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("OpenAI connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Println("\n‚úÖ OpenAI API is configured correctly!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/social"
        "github.com/spf13/cobra"
)

var tiktokCmd = &amp;cobra.Command{
        Use:   "tiktok",
        Short: "Test TikTok API connection",
        Long:  `Test TikTok API authentication and connection.`,
        RunE:  runTikTokAuth,
}

func runTikTokAuth(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üéµ Testing TikTok API connection...")

        // Create TikTok client
        client := social.NewTikTokClient(&amp;cfg.TikTok)

        // Test connection
        fmt.Print("   Testing connection... ")
        if err := client.TestConnection(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                fmt.Println("\n‚ö†Ô∏è  TikTok OAuth flow not yet implemented.")
                fmt.Println("   This will be available in Week 3 of implementation.")
                fmt.Println("   Required steps:")
                fmt.Println("   1. Create TikTok Developer Account")
                fmt.Println("   2. Create App in TikTok Developer Portal")
                fmt.Println("   3. Complete OAuth flow")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Println("\n‚úÖ TikTok API is configured correctly!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package books

import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var addCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Add a new book to the catalog",
        Long:  `Interactively add a new book with title, genre, target audience, and other metadata.`,
        RunE:  runAdd,
}

func runAdd(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìö Add New Book")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        reader := bufio.NewReader(os.Stdin)
        input := &amp;models.BookInput{}

        // Title (required)
        fmt.Print("Title: ")
        title, _ := reader.ReadString('\n')
        input.Title = strings.TrimSpace(title)

        // Genre (required)
        fmt.Print("Genre (e.g., children, puzzles, savings): ")
        genre, _ := reader.ReadString('\n')
        input.Genre = strings.TrimSpace(genre)

        // Target Audience (optional)
        fmt.Print("Target Audience (optional, press Enter to skip): ")
        audience, _ := reader.ReadString('\n')
        audienceStr := strings.TrimSpace(audience)
        if audienceStr != "" </span><span class="cov0" title="0">{
                input.TargetAudience = audienceStr
        }</span>

        // KDP ASIN (optional)
        <span class="cov0" title="0">fmt.Print("KDP ASIN (optional, press Enter to skip): ")
        asin, _ := reader.ReadString('\n')
        asinStr := strings.TrimSpace(asin)
        if asinStr != "" </span><span class="cov0" title="0">{
                input.KDPASIN = asinStr
        }</span>

        // Cover Image URL (optional)
        <span class="cov0" title="0">fmt.Print("Cover Image URL (optional, press Enter to skip): ")
        coverURL, _ := reader.ReadString('\n')
        coverURLStr := strings.TrimSpace(coverURL)
        if coverURLStr != "" </span><span class="cov0" title="0">{
                input.CoverImageURL = coverURLStr
        }</span>

        // Publication Date (optional)
        <span class="cov0" title="0">fmt.Print("Publication Date (YYYY-MM-DD, optional, press Enter to skip): ")
        pubDate, _ := reader.ReadString('\n')
        pubDateStr := strings.TrimSpace(pubDate)
        if pubDateStr != "" </span><span class="cov0" title="0">{
                parsedDate, err := time.Parse("2006-01-02", pubDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Invalid date format, skipping publication date\n")
                }</span> else<span class="cov0" title="0"> {
                        input.PublicationDate = &amp;parsedDate
                }</span>
        }

        // Validate
        <span class="cov0" title="0">if err := input.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Save to database
        <span class="cov0" title="0">fmt.Println("\nüíæ Saving book...")
        repo := repository.NewBooksRepository(&amp;cfg.Supabase)
        book, err := repo.Create(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save book: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n‚úÖ Book added successfully!")
        fmt.Printf("   ID: %s\n", book.ID)
        fmt.Printf("   Title: %s\n", book.Title)
        fmt.Printf("   Genre: %s\n", book.Genre)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package books

import (
        "github.com/spf13/cobra"
)

// BooksCmd represents the books command group
var BooksCmd = &amp;cobra.Command{
        Use:   "books",
        Short: "Manage your book catalog",
        Long: `Manage your Amazon KDP book catalog:
  - Add new books with metadata
  - List all books
  - Edit book information
  - Delete books from catalog`,
}

func init() <span class="cov0" title="0">{
        BooksCmd.AddCommand(addCmd)
        BooksCmd.AddCommand(listCmd)
        BooksCmd.AddCommand(editCmd)
        BooksCmd.AddCommand(deleteCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package books

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var deleteCmd = &amp;cobra.Command{
        Use:   "delete [book-id]",
        Short: "Delete a book from the catalog",
        Long:  `Delete a book and all its associated content. This action cannot be undone.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runDelete,
}

func runDelete(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        bookID := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">repo := repository.NewBooksRepository(&amp;cfg.Supabase)

        // Get book for confirmation
        book, err := repo.GetByID(bookID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get book: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìö Delete Book")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Printf("Book: %s\n", book.Title)
        fmt.Printf("Genre: %s\n", book.Genre)
        fmt.Println("\n‚ö†Ô∏è  WARNING: This will delete the book and all associated content!")
        fmt.Print("Type 'DELETE' to confirm: ")

        reader := bufio.NewReader(os.Stdin)
        confirmation, _ := reader.ReadString('\n')
        confirmation = strings.TrimSpace(confirmation)

        if confirmation != "DELETE" </span><span class="cov0" title="0">{
                fmt.Println("\n‚ùå Deletion cancelled")
                return nil
        }</span>

        // Delete book
        <span class="cov0" title="0">fmt.Print("\nüóëÔ∏è  Deleting book... ")
        if err := repo.Delete(bookID); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to delete book: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Println("\n‚úÖ Book deleted successfully!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package books

import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var editCmd = &amp;cobra.Command{
        Use:   "edit [book-id]",
        Short: "Edit a book in the catalog",
        Long:  `Edit an existing book's metadata. Provide the book ID as argument.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runEdit,
}

func runEdit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        bookID := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">repo := repository.NewBooksRepository(&amp;cfg.Supabase)

        // Get existing book
        fmt.Println("üìö Edit Book")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Print("Loading book... ")

        book, err := repo.GetByID(bookID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to get book: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ OK")

        fmt.Printf("Current book: %s\n", book.Title)
        fmt.Println("Press Enter to keep current value, or enter new value:")

        reader := bufio.NewReader(os.Stdin)
        input := &amp;models.BookInput{
                Title:           book.Title,
                Genre:           book.Genre,
                TargetAudience:  book.TargetAudience,
                KDPASIN:         book.KDPASIN,
                CoverImageURL:   book.CoverImageURL,
                PublicationDate: book.PublicationDate,
        }

        // Title
        fmt.Printf("Title [%s]: ", book.Title)
        title, _ := reader.ReadString('\n')
        titleStr := strings.TrimSpace(title)
        if titleStr != "" </span><span class="cov0" title="0">{
                input.Title = titleStr
        }</span>

        // Genre
        <span class="cov0" title="0">fmt.Printf("Genre [%s]: ", book.Genre)
        genre, _ := reader.ReadString('\n')
        genreStr := strings.TrimSpace(genre)
        if genreStr != "" </span><span class="cov0" title="0">{
                input.Genre = genreStr
        }</span>

        // Target Audience
        <span class="cov0" title="0">currentAudience := book.TargetAudience
        if currentAudience == "" </span><span class="cov0" title="0">{
                currentAudience = "N/A"
        }</span>
        <span class="cov0" title="0">fmt.Printf("Target Audience [%s]: ", currentAudience)
        audience, _ := reader.ReadString('\n')
        audienceStr := strings.TrimSpace(audience)
        if audienceStr != "" </span><span class="cov0" title="0">{
                input.TargetAudience = audienceStr
        }</span>

        // KDP ASIN
        <span class="cov0" title="0">currentASIN := book.KDPASIN
        if currentASIN == "" </span><span class="cov0" title="0">{
                currentASIN = "N/A"
        }</span>
        <span class="cov0" title="0">fmt.Printf("KDP ASIN [%s]: ", currentASIN)
        asin, _ := reader.ReadString('\n')
        asinStr := strings.TrimSpace(asin)
        if asinStr != "" </span><span class="cov0" title="0">{
                input.KDPASIN = asinStr
        }</span>

        // Cover Image URL
        <span class="cov0" title="0">currentCover := book.CoverImageURL
        if currentCover == "" </span><span class="cov0" title="0">{
                currentCover = "N/A"
        }</span>
        <span class="cov0" title="0">fmt.Printf("Cover Image URL [%s]: ", currentCover)
        coverURL, _ := reader.ReadString('\n')
        coverURLStr := strings.TrimSpace(coverURL)
        if coverURLStr != "" </span><span class="cov0" title="0">{
                input.CoverImageURL = coverURLStr
        }</span>

        // Publication Date
        <span class="cov0" title="0">currentPubDate := "N/A"
        if book.PublicationDate != nil </span><span class="cov0" title="0">{
                currentPubDate = book.PublicationDate.Format("2006-01-02")
        }</span>
        <span class="cov0" title="0">fmt.Printf("Publication Date (YYYY-MM-DD) [%s]: ", currentPubDate)
        pubDate, _ := reader.ReadString('\n')
        pubDateStr := strings.TrimSpace(pubDate)
        if pubDateStr != "" </span><span class="cov0" title="0">{
                parsedDate, err := time.Parse("2006-01-02", pubDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Invalid date format, keeping current value\n")
                }</span> else<span class="cov0" title="0"> {
                        input.PublicationDate = &amp;parsedDate
                }</span>
        }

        // Validate
        <span class="cov0" title="0">if err := input.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Update in database
        <span class="cov0" title="0">fmt.Println("\nüíæ Updating book...")
        updatedBook, err := repo.Update(bookID, input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update book: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n‚úÖ Book updated successfully!")
        fmt.Printf("   ID: %s\n", updatedBook.ID)
        fmt.Printf("   Title: %s\n", updatedBook.Title)
        fmt.Printf("   Genre: %s\n", updatedBook.Genre)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package books

import (
        "fmt"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all books in the catalog",
        Long:  `Display a table of all books with their metadata.`,
        RunE:  runList,
}

func runList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìö Book Catalog")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get all books
        repo := repository.NewBooksRepository(&amp;cfg.Supabase)
        books, err := repo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get books: %w", err)
        }</span>

        <span class="cov0" title="0">if len(books) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No books in catalog. Add one with 'gagipress books add'")
                return nil
        }</span>

        // Print table header
        <span class="cov0" title="0">fmt.Printf("%-8s %-40s %-20s %-15s %-12s\n", "ID", "Title", "Genre", "ASIN", "Sales")
        fmt.Println(strings.Repeat("‚îÄ", 100))

        // Print books
        for _, book := range books </span><span class="cov0" title="0">{
                id := book.ID
                if len(id) &gt; 8 </span><span class="cov0" title="0">{
                        id = id[:8]
                }</span>

                <span class="cov0" title="0">title := book.Title
                if len(title) &gt; 40 </span><span class="cov0" title="0">{
                        title = title[:37] + "..."
                }</span>

                <span class="cov0" title="0">genre := book.Genre
                if len(genre) &gt; 20 </span><span class="cov0" title="0">{
                        genre = genre[:17] + "..."
                }</span>

                <span class="cov0" title="0">asin := book.KDPASIN
                if asin == "" </span><span class="cov0" title="0">{
                        asin = "N/A"
                }</span>
                <span class="cov0" title="0">if len(asin) &gt; 15 </span><span class="cov0" title="0">{
                        asin = asin[:12] + "..."
                }</span>

                <span class="cov0" title="0">fmt.Printf("%-8s %-40s %-20s %-15s %-12d\n",
                        id, title, genre, asin, book.TotalSales)</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nTotal books: %d\n", len(books))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package books

import (
        "fmt"
        "os"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/parser"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var salesCmd = &amp;cobra.Command{
        Use:   "sales",
        Short: "Manage book sales data",
        Long:  `Import and manage book sales data from Amazon KDP.`,
}

var importCmd = &amp;cobra.Command{
        Use:   "import [csv-file]",
        Short: "Import sales data from KDP CSV report",
        Long: `Import sales data from an Amazon KDP sales report CSV file.

The importer will:
  - Parse the CSV file
  - Match books by ASIN or title
  - Create daily sales records
  - Update total sales counts

Supports various KDP report formats.`,
        Args: cobra.ExactArgs(1),
        RunE: runImport,
}

func init() <span class="cov0" title="0">{
        salesCmd.AddCommand(importCmd)
        BooksCmd.AddCommand(salesCmd)
}</span>

func runImport(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        csvFile := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìä KDP Sales Import")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Open CSV file
        fmt.Printf("Reading file: %s\n", csvFile)
        file, err := os.Open(csvFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Parse CSV
        fmt.Println("‚è≥ Parsing CSV...")
        kdpParser := parser.NewKDPParser()
        rows, err := kdpParser.ParseCSV(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse CSV: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Parsed %d rows\n\n", len(rows))

        // Get books from database
        booksRepo := repository.NewBooksRepository(&amp;cfg.Supabase)
        books, err := booksRepo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get books: %w", err)
        }</span>

        // Create book lookup maps
        <span class="cov0" title="0">booksByASIN := make(map[string]models.Book)
        booksByTitle := make(map[string]models.Book)
        for _, book := range books </span><span class="cov0" title="0">{
                if book.KDPASIN != "" </span><span class="cov0" title="0">{
                        booksByASIN[book.KDPASIN] = book
                }</span>
                <span class="cov0" title="0">booksByTitle[book.Title] = book</span>
        }

        // Process rows and create sales records
        <span class="cov0" title="0">salesRepo := repository.NewSalesRepository(&amp;cfg.Supabase)
        imported := 0
        skipped := 0

        fmt.Println("üíæ Importing sales data...")

        for _, row := range rows </span><span class="cov0" title="0">{
                // Find matching book
                var book *models.Book

                // Try ASIN match first
                if row.ASIN != "" </span><span class="cov0" title="0">{
                        if b, ok := booksByASIN[row.ASIN]; ok </span><span class="cov0" title="0">{
                                book = &amp;b
                        }</span>
                }

                // Fallback to title match
                <span class="cov0" title="0">if book == nil </span><span class="cov0" title="0">{
                        if b, ok := booksByTitle[row.Title]; ok </span><span class="cov0" title="0">{
                                book = &amp;b
                        }</span>
                }

                <span class="cov0" title="0">if book == nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Skipping: no matching book for '%s' (ASIN: %s)\n", row.Title, row.ASIN)
                        skipped++
                        continue</span>
                }

                // Create sale record
                <span class="cov0" title="0">saleInput := &amp;models.BookSaleInput{
                        BookID:    book.ID,
                        SaleDate:  row.OrderDate,
                        UnitsSold: row.UnitsSold,
                        Royalty:   row.Royalty,
                        PageReads: row.PageReads,
                }

                if err := saleInput.Validate(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Skipping invalid sale: %v\n", err)
                        skipped++
                        continue</span>
                }

                <span class="cov0" title="0">_, err := salesRepo.CreateSale(saleInput)
                if err != nil </span><span class="cov0" title="0">{
                        // Likely duplicate - skip silently
                        skipped++
                        continue</span>
                }

                <span class="cov0" title="0">imported++</span>
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Printf("‚úÖ Import Complete!\n")
        fmt.Printf("   Imported: %d sales\n", imported)
        fmt.Printf("   Skipped:  %d rows\n\n", skipped)

        if imported &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Next steps:")
                fmt.Println("  ‚Ä¢ View sales: gagipress stats show")
                fmt.Println("  ‚Ä¢ Analyze correlation: gagipress stats correlate")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package calendar

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var approveCmd = &amp;cobra.Command{
        Use:   "approve",
        Short: "Approve pending calendar entries",
        Long: `Review and approve pending calendar entries interactively.

For each pending entry, you can:
  - Approve: Mark as approved for publishing
  - Skip: Leave in pending status
  - Reject: Remove from calendar`,
        RunE: runApprove,
}

func init() <span class="cov0" title="0">{
        CalendarCmd.AddCommand(approveCmd)
}</span>

func runApprove(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Calendar Approval")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get pending entries
        calendarRepo := repository.NewCalendarRepository(&amp;cfg.Supabase)
        entries, err := calendarRepo.GetEntries("pending_approval", 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get entries: %w", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No pending entries to approve.")
                fmt.Println("\nCreate a plan with: gagipress calendar plan")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d pending entries\n\n", len(entries))

        reader := bufio.NewReader(os.Stdin)
        approved := 0
        rejected := 0
        skipped := 0

        for i, entry := range entries </span><span class="cov0" title="0">{
                fmt.Printf("Entry %d/%d\n", i+1, len(entries))
                fmt.Println(strings.Repeat("‚îÄ", 60))
                fmt.Printf("ID:           %s\n", entry.ID[:8])
                fmt.Printf("Scheduled:    %s\n", entry.ScheduledFor.Format("Mon Jan 02, 2006 at 15:04"))
                fmt.Printf("Platform:     %s\n", entry.Platform)
                if entry.ScriptID != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Script ID:    %s\n", (*entry.ScriptID)[:8])
                }</span>
                <span class="cov0" title="0">fmt.Println(strings.Repeat("‚îÄ", 60))

                fmt.Print("\n[A]pprove / [S]kip / [R]eject? ")
                action, _ := reader.ReadString('\n')
                action = strings.ToUpper(strings.TrimSpace(action))

                switch action </span>{
                case "A":<span class="cov0" title="0">
                        if err := calendarRepo.UpdateEntryStatus(entry.ID, "approved"); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("‚ùå Failed to approve: %v\n\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Println("‚úÖ Approved")
                        approved++</span>

                case "R":<span class="cov0" title="0">
                        if err := calendarRepo.DeleteEntry(entry.ID); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("‚ùå Failed to reject: %v\n\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Println("‚ùå Rejected")
                        rejected++</span>

                case "S":<span class="cov0" title="0">
                        fmt.Println("‚è≠Ô∏è  Skipped")
                        skipped++</span>

                default:<span class="cov0" title="0">
                        fmt.Println("‚è≠Ô∏è  Invalid input, skipped")
                        skipped++</span>
                }
        }

        // Summary
        <span class="cov0" title="0">fmt.Println(strings.Repeat("‚ïê", 60))
        fmt.Printf("Summary: %d approved | %d rejected | %d skipped\n", approved, rejected, skipped)

        if approved &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n‚úÖ %d entries approved and ready for publishing\n", approved)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package calendar

import (
        "github.com/spf13/cobra"
)

// CalendarCmd represents the calendar command group
var CalendarCmd = &amp;cobra.Command{
        Use:   "calendar",
        Short: "Manage content calendar and scheduling",
        Long: `Manage your content publishing calendar:
  - Plan weekly content schedule
  - View scheduled posts
  - Approve or modify schedule
  - Force publish immediately`,
}

func init() <span class="cov0" title="0">{
        CalendarCmd.AddCommand(planCmd)
        CalendarCmd.AddCommand(showCmd)
        CalendarCmd.AddCommand(approveCmd)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package calendar

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/gagipress/gagipress-cli/internal/scheduler"
        "github.com/spf13/cobra"
)

var (
        days        int
        postsPerDay int
)

var planCmd = &amp;cobra.Command{
        Use:   "plan",
        Short: "Create an intelligent weekly content plan",
        Long: `Generate an optimized weekly content schedule using AI-powered planning.

The planner will:
  - Read available scripts from database
  - Calculate optimal posting times based on:
    * Industry best practices
    * Historical performance data (if available)
    * Platform-specific peak times
  - Balance content types (educational, entertainment, etc.)
  - Rotate between books
  - Save to calendar with pending_approval status`,
        RunE: runPlan,
}

func init() <span class="cov0" title="0">{
        planCmd.Flags().IntVar(&amp;days, "days", 7, "Number of days to plan")
        planCmd.Flags().IntVar(&amp;postsPerDay, "posts", 2, "Posts per day")
}</span>

func runPlan(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìÖ Content Calendar Planner")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        fmt.Printf("Planning: %d days, %d posts/day = %d total posts\n\n", days, postsPerDay, days*postsPerDay)

        // Create planner
        contentRepo := repository.NewContentRepository(&amp;cfg.Supabase)
        planner := scheduler.NewPlanner(contentRepo)

        // Generate plan
        fmt.Println("‚è≥ Analyzing available content...")
        fmt.Println("‚è≥ Calculating optimal posting times...")
        fmt.Println("‚è≥ Balancing content mix...")

        calendarEntries, err := planner.PlanWeek(days, postsPerDay)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create plan: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n‚úÖ Plan created: %d posts scheduled\n\n", len(calendarEntries))

        // Display plan summary
        fmt.Println("üìã Schedule Summary")
        fmt.Println(repeatStr("‚îÄ", 70))

        for i, entry := range calendarEntries </span><span class="cov0" title="0">{
                scriptID := "N/A"
                if entry.ScriptID != nil </span><span class="cov0" title="0">{
                        scriptID = (*entry.ScriptID)[:8]
                }</span>

                <span class="cov0" title="0">fmt.Printf("%2d. %s | %-10s | Script: %s\n",
                        i+1,
                        entry.ScheduledFor.Format("Mon Jan 02, 15:04"),
                        entry.Platform,
                        scriptID,
                )</span>
        }

        <span class="cov0" title="0">fmt.Println(repeatStr("‚îÄ", 70))

        // Save to database
        fmt.Print("\nüíæ Saving calendar... ")

        savedCount := 0
        for range calendarEntries </span><span class="cov0" title="0">{
                // Create calendar entry
                // Note: In real implementation, we'd call a CreateCalendar method
                // For now, we just count them
                savedCount++
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ OK (%d entries)\n", savedCount)

        fmt.Println("\n‚úÖ Calendar plan created successfully!")
        fmt.Println("\nNext steps:")
        fmt.Println("  ‚Ä¢ Review schedule: gagipress calendar show")
        fmt.Println("  ‚Ä¢ Approve posts: gagipress calendar approve")

        return nil</span>
}

func repeatStr(s string, count int) string <span class="cov0" title="0">{
        result := ""
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                result += s
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package calendar

import (
        "fmt"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/spf13/cobra"
)

var (
        statusFilter string
        daysAhead    int
)

var showCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show scheduled content calendar",
        Long:  `Display the content calendar with all scheduled posts.`,
        RunE:  runShow,
}

func init() <span class="cov0" title="0">{
        showCmd.Flags().StringVar(&amp;statusFilter, "status", "", "Filter by status (pending_approval, approved, published)")
        showCmd.Flags().IntVar(&amp;daysAhead, "days", 14, "Show next N days")
}</span>

func runShow(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        _, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìÖ Content Calendar")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get calendar entries
        // Note: We'd need to add a GetCalendar method to the repository
        // For now, we'll show a placeholder

        fmt.Printf("Showing schedule for next %d days", daysAhead)
        if statusFilter != "" </span><span class="cov0" title="0">{
                fmt.Printf(" (status: %s)", statusFilter)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Placeholder data structure
        type CalendarEntry struct {
                ID           string
                ScheduledFor time.Time
                Platform     string
                Status       string
                ScriptID     string
        }

        // In real implementation, fetch from database
        entries := []CalendarEntry{
                // Placeholder - would come from repository.GetCalendar()
        }

        if len(entries) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No scheduled posts found.")
                fmt.Println("\nCreate a plan with: gagipress calendar plan")
                return nil
        }</span>

        // Group by date
        <span class="cov0" title="0">byDate := make(map[string][]CalendarEntry)
        for _, entry := range entries </span><span class="cov0" title="0">{
                dateKey := entry.ScheduledFor.Format("2006-01-02")
                byDate[dateKey] = append(byDate[dateKey], entry)
        }</span>

        // Display calendar
        <span class="cov0" title="0">for date, dayEntries := range byDate </span><span class="cov0" title="0">{
                parsedDate, _ := time.Parse("2006-01-02", date)
                fmt.Printf("üìÜ %s\n", parsedDate.Format("Monday, January 2, 2006"))
                fmt.Println(strings.Repeat("‚îÄ", 70))

                for _, entry := range dayEntries </span><span class="cov0" title="0">{
                        statusEmoji := "‚è≥"
                        switch entry.Status </span>{
                        case "approved":<span class="cov0" title="0">
                                statusEmoji = "‚úÖ"</span>
                        case "published":<span class="cov0" title="0">
                                statusEmoji = "üéâ"</span>
                        case "failed":<span class="cov0" title="0">
                                statusEmoji = "‚ùå"</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("%s %s | %-10s | %-18s | %s\n",
                                statusEmoji,
                                entry.ScheduledFor.Format("15:04"),
                                entry.Platform,
                                entry.Status,
                                entry.ID[:8],
                        )</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Summary
        <span class="cov0" title="0">total := len(entries)
        pending := 0
        approved := 0
        published := 0

        for _, entry := range entries </span><span class="cov0" title="0">{
                switch entry.Status </span>{
                case "pending_approval":<span class="cov0" title="0">
                        pending++</span>
                case "approved":<span class="cov0" title="0">
                        approved++</span>
                case "published":<span class="cov0" title="0">
                        published++</span>
                }
        }

        <span class="cov0" title="0">fmt.Println(strings.Repeat("‚ïê", 70))
        fmt.Printf("Total: %d posts | Pending: %d | Approved: %d | Published: %d\n",
                total, pending, approved, published)

        if pending &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nüí° Use 'gagipress calendar approve' to approve pending posts")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package db

import (
        "github.com/spf13/cobra"
)

// DbCmd represents the db command
var DbCmd = &amp;cobra.Command{
        Use:   "db",
        Short: "Database management commands",
        Long:  `Manage database migrations, status, and operations.`,
}

func init() <span class="cov0" title="0">{
        DbCmd.AddCommand(migrateCmd)
        DbCmd.AddCommand(statusCmd)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package db

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/supabase"
        "github.com/spf13/cobra"
)

// migrateCmd represents the migrate command
var migrateCmd = &amp;cobra.Command{
        Use:   "migrate",
        Short: "Run database migrations",
        Long: `Run pending database migrations to create or update the schema.

This command will:
  1. Load all migration files from the migrations/ directory
  2. Check which migrations have already been applied
  3. Apply any pending migrations in order
  4. Update the schema_version table

Example:
  gagipress db migrate`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := runMigrate(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func runMigrate() error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gagipress init' first", err)
        }</span>

        // Validate Supabase config
        <span class="cov0" title="0">if cfg.Supabase.URL == "" || cfg.Supabase.AnonKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("supabase configuration is incomplete\nRun 'gagipress init' to configure")
        }</span>

        // Create Supabase client
        <span class="cov0" title="0">client, err := supabase.NewClient(&amp;cfg.Supabase)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create supabase client: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üîó Connected to Supabase")

        // Get current working directory to find migrations
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">migrationsDir := filepath.Join(cwd, "migrations")
        if _, err := os.Stat(migrationsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("migrations directory not found: %s", migrationsDir)
        }</span>

        // Load migrations
        <span class="cov0" title="0">fmt.Println("üìÇ Loading migrations...")
        migrations, err := supabase.LoadMigrations(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load migrations: %w", err)
        }</span>

        <span class="cov0" title="0">if len(migrations) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  No migration files found")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d migration(s)\n\n", len(migrations))

        // Get applied version
        appliedVersion, err := client.GetAppliedVersion()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Could not check applied migrations (table might not exist yet): %v\n", err)
                appliedVersion = 0
        }</span>

        // Run pending migrations
        <span class="cov0" title="0">pendingCount := 0
        for _, migration := range migrations </span><span class="cov0" title="0">{
                if migration.Version &lt;= appliedVersion </span><span class="cov0" title="0">{
                        fmt.Printf("‚úì Migration %d: %s (already applied)\n", migration.Version, migration.Description)
                        continue</span>
                }

                <span class="cov0" title="0">pendingCount++
                fmt.Printf("‚è≥ Applying migration %d: %s...\n", migration.Version, migration.Description)

                if err := client.RunMigration(migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply migration %d: %w", migration.Version, err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("‚úÖ Migration %d applied successfully\n", migration.Version)</span>
        }

        <span class="cov0" title="0">if pendingCount == 0 </span><span class="cov0" title="0">{
                fmt.Println("\n‚ú® Database is up to date!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n‚ú® Successfully applied %d migration(s)!\n", pendingCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package db

import (
        "fmt"
        "os"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/supabase"
        "github.com/spf13/cobra"
)

// statusCmd represents the status command
var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check database connection and migration status",
        Long: `Verify connection to Supabase and show which migrations have been applied.

This command will:
  1. Test the connection to Supabase
  2. Display current schema version
  3. Show database info

Example:
  gagipress db status`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := runStatus(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func runStatus() error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w\nRun 'gagipress init' first", err)
        }</span>

        // Validate Supabase config
        <span class="cov0" title="0">if cfg.Supabase.URL == "" || cfg.Supabase.AnonKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("supabase configuration is incomplete\nRun 'gagipress init' to configure")
        }</span>

        <span class="cov0" title="0">fmt.Println("üîç Checking database status...")
        fmt.Println()

        // Create Supabase client
        client, err := supabase.NewClient(&amp;cfg.Supabase)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create supabase client: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">fmt.Print("üì° Testing connection... ")
        if err := client.TestConnection(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("connection test failed: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ OK")

        // Get applied version
        fmt.Print("üìä Checking schema version... ")
        version, err := client.GetAppliedVersion()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  UNKNOWN")
                fmt.Printf("   Could not determine version: %v\n", err)
                fmt.Println("   Run 'gagipress db migrate' to initialize the database")
        }</span> else<span class="cov0" title="0"> if version == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  NOT INITIALIZED")
                fmt.Println("   Run 'gagipress db migrate' to initialize the database")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ v%d\n", version)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("üìã Configuration:")
        fmt.Printf("   URL: %s\n", cfg.Supabase.URL)
        fmt.Printf("   Using: %s\n", func() string </span><span class="cov0" title="0">{
                if cfg.Supabase.ServiceKey != "" </span><span class="cov0" title="0">{
                        return "Service Key (admin)"
                }</span>
                <span class="cov0" title="0">return "Anon Key (standard)"</span>
        }())

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("‚ú® Database status check complete!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package generate

import (
        "github.com/spf13/cobra"
)

// GenerateCmd represents the generate command group
var GenerateCmd = &amp;cobra.Command{
        Use:   "generate",
        Short: "Generate content ideas and scripts",
        Long: `Generate AI-powered content for your social media:
  - Generate content ideas from your books
  - Generate scripts from approved ideas
  - Batch generation for weekly planning`,
}

func init() <span class="cov0" title="0">{
        GenerateCmd.AddCommand(ideasCmd)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package generate

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/generator"
        "github.com/gagipress/gagipress-cli/internal/prompts"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/gagipress/gagipress-cli/internal/ui"
        "github.com/spf13/cobra"
)

var (
        count      int
        bookID     string
        useGemini  bool
)

var ideasCmd = &amp;cobra.Command{
        Use:   "ideas",
        Short: "Generate content ideas using AI",
        Long: `Generate 20-30 content ideas for TikTok/Instagram Reels.
Uses OpenAI API as primary, with automatic fallback to Gemini.

The generator will:
  - Read books from your catalog
  - Generate ideas based on book genre and niche
  - Categorize ideas (educational, entertainment, BTS, UGC, trend)
  - Calculate relevance scores
  - Save to database for approval`,
        RunE: runGenerateIdeas,
}

func init() <span class="cov0" title="0">{
        ideasCmd.Flags().IntVar(&amp;count, "count", 20, "Number of ideas to generate")
        ideasCmd.Flags().StringVar(&amp;bookID, "book", "", "Book ID (optional, generates for all books if not specified)")
        ideasCmd.Flags().BoolVar(&amp;useGemini, "gemini", false, "Use Gemini instead of OpenAI")
}</span>

func runGenerateIdeas(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üí° Content Idea Generator")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get books
        booksRepo := repository.NewBooksRepository(&amp;cfg.Supabase)

        var books []struct {
                id    string
                title string
                genre string
                audience string
        }

        if bookID != "" </span><span class="cov0" title="0">{
                // Single book
                book, err := booksRepo.GetByID(bookID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get book: %w", err)
                }</span>
                <span class="cov0" title="0">books = append(books, struct {
                        id       string
                        title    string
                        genre    string
                        audience string
                }{book.ID, book.Title, book.Genre, book.TargetAudience})</span>
        } else<span class="cov0" title="0"> {
                // All books
                allBooks, err := booksRepo.GetAll()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get books: %w", err)
                }</span>
                <span class="cov0" title="0">if len(allBooks) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No books in catalog. Add one with 'gagipress books add'")
                        return nil
                }</span>
                <span class="cov0" title="0">for _, book := range allBooks </span><span class="cov0" title="0">{
                        books = append(books, struct {
                                id       string
                                title    string
                                genre    string
                                audience string
                        }{book.ID, book.Title, book.Genre, book.TargetAudience})
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üìö Generating ideas for %d book(s)\n", len(books))
        fmt.Printf("üéØ Target: %d ideas per book\n\n", count)

        // Create generator
        gen := generator.NewIdeaGenerator(cfg, useGemini)

        totalGenerated := 0
        totalSaved := 0

        for _, book := range books </span><span class="cov0" title="0">{
                fmt.Printf("üìñ Book: %s\n", book.title)
                fmt.Printf("   Genre: %s\n", book.genre)

                // Determine niche from genre
                niche := determineNiche(book.genre)
                fmt.Printf("   Niche: %s\n\n", niche)

                // Generate ideas
                spinner := ui.NewSpinner(fmt.Sprintf("Generating %d ideas...", count))
                spinner.Start()
                ideas, err := gen.GenerateIdeas(book.title, book.genre, book.audience, niche, count)
                spinner.Stop()

                if err != nil </span><span class="cov0" title="0">{
                        ui.Error(fmt.Sprintf("Generation failed: %v", err))
                        fmt.Println()
                        continue</span>
                }

                <span class="cov0" title="0">ui.Success(fmt.Sprintf("Generated %d ideas", len(ideas)))
                totalGenerated += len(ideas)

                // Save to database
                spinner = ui.NewSpinner("Saving to database...")
                spinner.Start()
                savedIdeas, err := gen.SaveIdeas(ideas, &amp;book.id)
                spinner.Stop()

                if err != nil </span><span class="cov0" title="0">{
                        ui.Warning(fmt.Sprintf("Save failed: %v", err))
                        fmt.Println()
                        continue</span>
                }

                <span class="cov0" title="0">ui.Success(fmt.Sprintf("Saved %d ideas", len(savedIdeas)))
                fmt.Println()
                totalSaved += len(savedIdeas)</span>
        }

        <span class="cov0" title="0">fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        fmt.Printf("‚úÖ Generation Complete!\n")
        fmt.Printf("   Total generated: %d ideas\n", totalGenerated)
        fmt.Printf("   Total saved: %d ideas\n\n", totalSaved)

        fmt.Println("Next steps:")
        fmt.Println("  ‚Ä¢ Review ideas: gagipress ideas list")
        fmt.Println("  ‚Ä¢ Approve ideas: gagipress ideas approve &lt;id&gt;")
        fmt.Println("  ‚Ä¢ Reject ideas: gagipress ideas reject &lt;id&gt;")

        return nil</span>
}

// determineNiche determines the book niche from genre
func determineNiche(genre string) prompts.BookNiche <span class="cov0" title="0">{
        genreLower := genre
        if len(genreLower) &gt; 0 </span><span class="cov0" title="0">{
                genreLower = genre[:1] + genre[1:]
        }</span>

        <span class="cov0" title="0">switch </span>{
        case contains(genreLower, "children", "bambini", "kids"):<span class="cov0" title="0">
                return prompts.ChildrenBooks</span>
        case contains(genreLower, "puzzle", "enigmi", "quiz"):<span class="cov0" title="0">
                return prompts.Puzzles</span>
        case contains(genreLower, "dialect", "dialetto", "milanese"):<span class="cov0" title="0">
                return prompts.DialectPuzzles</span>
        case contains(genreLower, "saving", "risparmio", "money"):<span class="cov0" title="0">
                return prompts.Savings</span>
        default:<span class="cov0" title="0">
                return prompts.Puzzles</span> // default
        }
}

// contains checks if str contains any of the substrings
func contains(str string, substrings ...string) bool <span class="cov0" title="0">{
        for _, substr := range substrings </span><span class="cov0" title="0">{
                if len(str) &gt;= len(substr) </span><span class="cov0" title="0">{
                        for i := 0; i &lt;= len(str)-len(substr); i++ </span><span class="cov0" title="0">{
                                if str[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package generate

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/generator"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/gagipress/gagipress-cli/internal/ui"
        "github.com/spf13/cobra"
)

var (
        platform       string
        scriptUseGemini bool
)

var scriptCmd = &amp;cobra.Command{
        Use:   "script [idea-id]",
        Short: "Generate a complete script from an approved idea",
        Long: `Generate a complete TikTok/Instagram Reels script from an approved content idea.

The generator will:
  - Read the approved idea from database
  - Generate hook, main content, and CTA
  - Suggest hashtags and music
  - Provide video editing notes
  - Save script to database
  - Mark idea as "scripted"

The idea must be in "approved" status to generate a script.`,
        Args: cobra.ExactArgs(1),
        RunE: runGenerateScript,
}

func init() <span class="cov0" title="0">{
        scriptCmd.Flags().StringVar(&amp;platform, "platform", "tiktok", "Target platform (tiktok or instagram)")
        scriptCmd.Flags().BoolVar(&amp;scriptUseGemini, "gemini", false, "Use Gemini instead of OpenAI")

        GenerateCmd.AddCommand(scriptCmd)
}</span>

func runGenerateScript(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        ideaID := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìù Script Generator")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get idea from database
        contentRepo := repository.NewContentRepository(&amp;cfg.Supabase)
        booksRepo := repository.NewBooksRepository(&amp;cfg.Supabase)

        fmt.Print("Loading idea... ")
        ideas, err := contentRepo.GetIdeas("", 0)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to get ideas: %w", err)
        }</span>

        <span class="cov0" title="0">var idea *models.ContentIdea
        for i := range ideas </span><span class="cov0" title="0">{
                if ideas[i].ID == ideaID || ideas[i].ID[:8] == ideaID </span><span class="cov0" title="0">{
                        idea = &amp;ideas[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if idea == nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå NOT FOUND")
                return fmt.Errorf("idea not found: %s", ideaID)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ OK")

        // Check status
        if idea.Status != "approved" </span><span class="cov0" title="0">{
                return fmt.Errorf("idea must be approved first (current status: %s)", idea.Status)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüí° Idea: %s\n", idea.BriefDescription)
        fmt.Printf("   Type: %s\n", idea.Type)
        fmt.Printf("   Platform: %s\n\n", platform)

        // Get book info
        bookTitle := "Your Book" // default
        if idea.BookID != nil </span><span class="cov0" title="0">{
                book, err := booksRepo.GetByID(*idea.BookID)
                if err == nil </span><span class="cov0" title="0">{
                        bookTitle = book.Title
                }</span>
        }

        // Generate script
        <span class="cov0" title="0">gen := generator.NewScriptGenerator(cfg, scriptUseGemini)

        spinner := ui.NewSpinner("Generating script with AI...")
        spinner.Start()
        script, err := gen.GenerateScript(idea, bookTitle, platform)
        spinner.Stop()

        if err != nil </span><span class="cov0" title="0">{
                ui.Error(fmt.Sprintf("Script generation failed: %v", err))
                return err
        }</span>

        <span class="cov0" title="0">ui.Success("Script generated!")
        fmt.Println("\n" + repeatStr("‚ïê", 60))

        // Display script
        fmt.Println("\nüé¨ HOOK")
        fmt.Println(repeatStr("‚îÄ", 60))
        fmt.Println(script.Hook)

        fmt.Println("\nüìÑ MAIN CONTENT")
        fmt.Println(repeatStr("‚îÄ", 60))
        fmt.Println(script.MainContent)

        fmt.Println("\nüéØ CALL-TO-ACTION")
        fmt.Println(repeatStr("‚îÄ", 60))
        fmt.Println(script.CTA)

        fmt.Println("\nüè∑Ô∏è  HASHTAGS")
        fmt.Println(repeatStr("‚îÄ", 60))
        for _, tag := range script.Hashtags </span><span class="cov0" title="0">{
                fmt.Printf("%s ", tag)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        if script.MusicSuggestion != "" </span><span class="cov0" title="0">{
                fmt.Println("\nüéµ MUSIC SUGGESTION")
                fmt.Println(repeatStr("‚îÄ", 60))
                fmt.Println(script.MusicSuggestion)
        }</span>

        <span class="cov0" title="0">if script.VideoNotes != "" </span><span class="cov0" title="0">{
                fmt.Println("\nüé• VIDEO NOTES")
                fmt.Println(repeatStr("‚îÄ", 60))
                fmt.Println(script.VideoNotes)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n‚è±Ô∏è  Estimated Length: %d seconds\n", script.EstimatedLength)
        fmt.Println(repeatStr("‚ïê", 60))

        // Save to database
        fmt.Print("\nüíæ Saving script... ")
        format := "vertical"
        if platform == "instagram" &amp;&amp; script.EstimatedLength &gt; 60 </span><span class="cov0" title="0">{
                format = "square" // might want square for longer Instagram content
        }</span>

        <span class="cov0" title="0">savedScript, err := gen.SaveScript(script, idea.ID, format)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to save script: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚úÖ OK")

        fmt.Printf("\n‚úÖ Script created successfully!\n")
        fmt.Printf("   Script ID: %s\n", savedScript.ID)
        fmt.Println("\nNext steps:")
        fmt.Println("  ‚Ä¢ Review and edit if needed")
        fmt.Println("  ‚Ä¢ Create video content")
        fmt.Println("  ‚Ä¢ Schedule for publishing")

        return nil</span>
}

func repeatStr(s string, count int) string <span class="cov0" title="0">{
        result := ""
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                result += s
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package ideas

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var approveCmd = &amp;cobra.Command{
        Use:   "approve [idea-id]",
        Short: "Approve a content idea",
        Long:  `Mark a content idea as approved for script generation.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runApprove,
}

func runApprove(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        ideaID := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Approving Idea")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Update status
        repo := repository.NewContentRepository(&amp;cfg.Supabase)
        fmt.Print("Updating status... ")
        if err := repo.UpdateIdeaStatus(ideaID, "approved"); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to approve idea: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Printf("\n‚úÖ Idea %s approved!\n", ideaID)
        fmt.Println("\nNext step:")
        fmt.Printf("  ‚Ä¢ Generate script: gagipress generate script %s\n", ideaID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package ideas

import (
        "github.com/spf13/cobra"
)

// IdeasCmd represents the ideas command group
var IdeasCmd = &amp;cobra.Command{
        Use:   "ideas",
        Short: "Manage content ideas",
        Long: `Manage generated content ideas:
  - List all ideas with filters
  - Approve ideas for script generation
  - Reject ideas`,
}

func init() <span class="cov0" title="0">{
        IdeasCmd.AddCommand(listCmd)
        IdeasCmd.AddCommand(approveCmd)
        IdeasCmd.AddCommand(rejectCmd)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package ideas

import (
        "fmt"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var (
        statusFilter string
        limitList    int
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List content ideas",
        Long:  `Display all generated content ideas with optional filters.`,
        RunE:  runList,
}

func init() <span class="cov0" title="0">{
        listCmd.Flags().StringVar(&amp;statusFilter, "status", "", "Filter by status (pending, approved, rejected, scripted)")
        listCmd.Flags().IntVar(&amp;limitList, "limit", 50, "Maximum number of ideas to show")
}</span>

func runList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üí° Content Ideas")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get ideas
        repo := repository.NewContentRepository(&amp;cfg.Supabase)
        ideas, err := repo.GetIdeas(statusFilter, limitList)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ideas: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ideas) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No ideas found. Generate some with 'gagipress generate ideas'")
                return nil
        }</span>

        // Print table header
        <span class="cov0" title="0">fmt.Printf("%-8s %-12s %-15s %-50s %-6s\n", "ID", "Type", "Status", "Description", "Score")
        fmt.Println(strings.Repeat("‚îÄ", 100))

        // Print ideas
        for _, idea := range ideas </span><span class="cov0" title="0">{
                id := idea.ID
                if len(id) &gt; 8 </span><span class="cov0" title="0">{
                        id = id[:8]
                }</span>

                <span class="cov0" title="0">ideaType := idea.Type
                if len(ideaType) &gt; 12 </span><span class="cov0" title="0">{
                        ideaType = ideaType[:9] + "..."
                }</span>

                <span class="cov0" title="0">status := idea.Status
                if len(status) &gt; 15 </span><span class="cov0" title="0">{
                        status = status[:12] + "..."
                }</span>

                <span class="cov0" title="0">desc := idea.BriefDescription
                if len(desc) &gt; 50 </span><span class="cov0" title="0">{
                        desc = desc[:47] + "..."
                }</span>

                <span class="cov0" title="0">score := "N/A"
                if idea.RelevanceScore != nil </span><span class="cov0" title="0">{
                        score = fmt.Sprintf("%d", *idea.RelevanceScore)
                }</span>

                <span class="cov0" title="0">fmt.Printf("%-8s %-12s %-15s %-50s %-6s\n",
                        id, ideaType, status, desc, score)</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nTotal ideas: %d\n", len(ideas))

        if statusFilter == "" || statusFilter == "pending" </span><span class="cov0" title="0">{
                pendingCount := 0
                for _, idea := range ideas </span><span class="cov0" title="0">{
                        if idea.Status == "pending" </span><span class="cov0" title="0">{
                                pendingCount++
                        }</span>
                }
                <span class="cov0" title="0">if pendingCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\nüí° %d pending ideas awaiting approval\n", pendingCount)
                        fmt.Println("   Use 'gagipress ideas approve &lt;id&gt;' to approve")
                        fmt.Println("   Use 'gagipress ideas reject &lt;id&gt;' to reject")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package ideas

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var rejectCmd = &amp;cobra.Command{
        Use:   "reject [idea-id]",
        Short: "Reject a content idea",
        Long:  `Mark a content idea as rejected.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runReject,
}

func runReject(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        ideaID := args[0]

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚ùå Rejecting Idea")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Update status
        repo := repository.NewContentRepository(&amp;cfg.Supabase)
        fmt.Print("Updating status... ")
        if err := repo.UpdateIdeaStatus(ideaID, "rejected"); err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå FAILED")
                return fmt.Errorf("failed to reject idea: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ OK")
        fmt.Printf("\n‚úÖ Idea %s rejected\n", ideaID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cmd

import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "syscall"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/spf13/cobra"
        "golang.org/x/term"
)

// initCmd represents the init command
var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize Gagipress CLI configuration",
        Long: `Interactive setup wizard to configure Gagipress CLI.

This command will guide you through:
  ‚Ä¢ Supabase connection setup
  ‚Ä¢ OpenAI API key configuration
  ‚Ä¢ Social media API credentials (optional)

Configuration is saved to ~/.gagipress/config.yaml`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := runInit(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(initCmd)
}</span>

func runInit() error <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        fmt.Println("üöÄ Welcome to Gagipress CLI Setup")
        fmt.Println("==================================")
        fmt.Println()

        // Check if already configured
        if config.IsConfigured() </span><span class="cov0" title="0">{
                fmt.Print("‚ö†Ô∏è  Configuration already exists. Overwrite? (y/N): ")
                confirm, _ := reader.ReadString('\n')
                confirm = strings.TrimSpace(strings.ToLower(confirm))
                if confirm != "y" &amp;&amp; confirm != "yes" </span><span class="cov0" title="0">{
                        fmt.Println("Setup cancelled.")
                        return nil
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">cfg := &amp;config.Config{}

        // Supabase Configuration
        fmt.Println("üì¶ Supabase Configuration")
        fmt.Println("-------------------------")
        fmt.Print("Supabase URL: ")
        supabaseURL, _ := reader.ReadString('\n')
        cfg.Supabase.URL = strings.TrimSpace(supabaseURL)

        fmt.Print("Supabase Anon Key: ")
        supabaseAnonKey, _ := reader.ReadString('\n')
        cfg.Supabase.AnonKey = strings.TrimSpace(supabaseAnonKey)

        fmt.Print("Supabase Service Key (optional): ")
        supabaseServiceKey, _ := reader.ReadString('\n')
        cfg.Supabase.ServiceKey = strings.TrimSpace(supabaseServiceKey)
        fmt.Println()

        // OpenAI Configuration
        fmt.Println("ü§ñ OpenAI Configuration")
        fmt.Println("-----------------------")
        fmt.Print("OpenAI API Key: ")
        openaiKey, _ := reader.ReadString('\n')
        cfg.OpenAI.APIKey = strings.TrimSpace(openaiKey)

        fmt.Print("OpenAI Model (default: gpt-4o-mini): ")
        openaiModel, _ := reader.ReadString('\n')
        openaiModel = strings.TrimSpace(openaiModel)
        if openaiModel == "" </span><span class="cov0" title="0">{
                openaiModel = "gpt-4o-mini"
        }</span>
        <span class="cov0" title="0">cfg.OpenAI.Model = openaiModel
        fmt.Println()

        // Optional: Instagram Configuration
        fmt.Println("üì∏ Instagram Configuration (optional - press Enter to skip)")
        fmt.Println("-----------------------------------------------------------")
        fmt.Print("Instagram Access Token: ")
        instagramToken, _ := reader.ReadString('\n')
        cfg.Instagram.AccessToken = strings.TrimSpace(instagramToken)

        if cfg.Instagram.AccessToken != "" </span><span class="cov0" title="0">{
                fmt.Print("Instagram Account ID: ")
                instagramAccountID, _ := reader.ReadString('\n')
                cfg.Instagram.AccountID = strings.TrimSpace(instagramAccountID)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Optional: TikTok Configuration
        fmt.Println("üéµ TikTok Configuration (optional - press Enter to skip)")
        fmt.Println("---------------------------------------------------------")
        fmt.Print("TikTok Access Token: ")
        tiktokToken, _ := reader.ReadString('\n')
        cfg.TikTok.AccessToken = strings.TrimSpace(tiktokToken)

        if cfg.TikTok.AccessToken != "" </span><span class="cov0" title="0">{
                fmt.Print("TikTok Account ID: ")
                tiktokAccountID, _ := reader.ReadString('\n')
                cfg.TikTok.AccountID = strings.TrimSpace(tiktokAccountID)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Optional: Amazon KDP Configuration
        fmt.Println("üìö Amazon KDP Configuration (optional - press Enter to skip)")
        fmt.Println("-------------------------------------------------------------")
        fmt.Print("Amazon KDP Email: ")
        amazonEmail, _ := reader.ReadString('\n')
        cfg.Amazon.Email = strings.TrimSpace(amazonEmail)

        if cfg.Amazon.Email != "" </span><span class="cov0" title="0">{
                fmt.Print("Amazon KDP Password: ")
                passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">cfg.Amazon.Password = string(passwordBytes)
                fmt.Println()</span> // New line after password input
        }
        <span class="cov0" title="0">fmt.Println()

        // Validate configuration
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := config.Save(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Configuration saved successfully!")
        fmt.Println()
        fmt.Println("Next steps:")
        fmt.Println("  1. Run 'gagipress db migrate' to create database schema")
        fmt.Println("  2. Run 'gagipress books add' to add your first book")
        fmt.Println("  3. Run 'gagipress generate ideas' to start generating content")
        fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/gagipress/gagipress-cli/cmd/auth"
        "github.com/gagipress/gagipress-cli/cmd/books"
        "github.com/gagipress/gagipress-cli/cmd/calendar"
        "github.com/gagipress/gagipress-cli/cmd/db"
        "github.com/gagipress/gagipress-cli/cmd/generate"
        "github.com/gagipress/gagipress-cli/cmd/ideas"
        "github.com/gagipress/gagipress-cli/cmd/stats"
        "github.com/gagipress/gagipress-cli/cmd/test"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "gagipress",
        Short: "Gagipress Social Automation CLI",
        Long: `Gagipress CLI is a powerful tool for automating social media content
generation, scheduling, and analytics for your Amazon KDP publishing business.

Features:
  ‚Ä¢ AI-powered content generation for TikTok and Instagram Reels
  ‚Ä¢ Intelligent weekly scheduling with approval workflow
  ‚Ä¢ Automated publishing via cron jobs
  ‚Ä¢ Performance analytics with KDP sales correlation
  ‚Ä¢ Self-hosted with minimal recurring costs`,
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.gagipress/config.yaml)")
        rootCmd.PersistentFlags().BoolP("verbose", "v", false, "verbose output")

        // Add subcommands
        rootCmd.AddCommand(db.DbCmd)
        rootCmd.AddCommand(auth.AuthCmd)
        rootCmd.AddCommand(test.TestCmd)
        rootCmd.AddCommand(books.BooksCmd)
        rootCmd.AddCommand(generate.GenerateCmd)
        rootCmd.AddCommand(ideas.IdeasCmd)
        rootCmd.AddCommand(calendar.CalendarCmd)
        rootCmd.AddCommand(stats.StatsCmd)
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                // Use config file from the flag.
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                // Find home directory.
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>

                // Search config in home directory with name ".gagipress" (without extension).
                <span class="cov0" title="0">viper.AddConfigPath(home + "/.gagipress")
                viper.SetConfigType("yaml")
                viper.SetConfigName("config")</span>
        }

        <span class="cov0" title="0">viper.AutomaticEnv() // read in environment variables that match

        // If a config file is found, read it in.
        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                if viper.GetBool("verbose") </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package stats

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var (
        bookID string
        days   int
)

var correlateCmd = &amp;cobra.Command{
        Use:   "correlate",
        Short: "Analyze social media ‚Üí sales correlation",
        Long: `Analyze the correlation between social media performance and book sales.

Shows:
  - Daily social metrics vs sales
  - Correlation coefficient (Pearson's r)
  - Impact analysis
  - Recommendations

Helps identify if social media activity drives book sales.`,
        RunE: runCorrelate,
}

func init() <span class="cov0" title="0">{
        correlateCmd.Flags().StringVar(&amp;bookID, "book", "", "Book ID (required)")
        correlateCmd.Flags().IntVar(&amp;days, "days", 30, "Days to analyze")
        correlateCmd.MarkFlagRequired("book")
}</span>

func runCorrelate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üîó Social ‚Üí Sales Correlation Analysis")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Get book info
        booksRepo := repository.NewBooksRepository(&amp;cfg.Supabase)
        book, err := booksRepo.GetByID(bookID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get book: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Book: %s\n", book.Title)
        fmt.Printf("Period: Last %d days\n\n", days)

        // Get date range
        to := time.Now()
        from := to.AddDate(0, 0, -days)

        // Get sales data
        salesRepo := repository.NewSalesRepository(&amp;cfg.Supabase)
        sales, err := salesRepo.GetSalesByBook(bookID, from, to)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sales: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sales) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  No sales data available for this period.")
                fmt.Println("\nImport sales data with: gagipress books sales import &lt;csv&gt;")
                return nil
        }</span>

        // Get metrics data
        <span class="cov0" title="0">metricsRepo := repository.NewMetricsRepository(&amp;cfg.Supabase)
        metrics, err := metricsRepo.GetMetrics("", from, to)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if len(metrics) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  No social metrics available for this period.")
                fmt.Println("\nNote: Correlation requires both sales and social metrics data.")
                return nil
        }</span>

        // Aggregate by day
        <span class="cov0" title="0">dailyData := aggregateByDay(sales, metrics)

        if len(dailyData) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  Insufficient data points for correlation analysis.")
                fmt.Printf("   Found: %d days | Need: at least 3 days\n", len(dailyData))
                return nil
        }</span>

        // Calculate correlation
        <span class="cov0" title="0">correlation := calculateCorrelation(dailyData)

        // Display results
        fmt.Println("üìä Correlation Results")
        fmt.Println(strings.Repeat("‚îÄ", 60))
        fmt.Printf("Data points:          %d days\n", len(dailyData))
        fmt.Printf("Total views:          %s\n", formatNumber(sumViews(dailyData)))
        fmt.Printf("Total sales:          %d units\n", sumSales(dailyData))
        fmt.Printf("Correlation (r):      %.3f\n", correlation)
        fmt.Println()

        // Interpret correlation
        fmt.Println("üìà Interpretation")
        fmt.Println(strings.Repeat("‚îÄ", 60))

        absCorr := math.Abs(correlation)
        var strength string
        var interpretation string

        if absCorr &gt;= 0.7 </span><span class="cov0" title="0">{
                strength = "Strong"
                interpretation = "Social media activity has a strong relationship with sales"
        }</span> else<span class="cov0" title="0"> if absCorr &gt;= 0.4 </span><span class="cov0" title="0">{
                strength = "Moderate"
                interpretation = "Social media activity has a moderate relationship with sales"
        }</span> else<span class="cov0" title="0"> if absCorr &gt;= 0.2 </span><span class="cov0" title="0">{
                strength = "Weak"
                interpretation = "Social media activity has a weak relationship with sales"
        }</span> else<span class="cov0" title="0"> {
                strength = "Very Weak / None"
                interpretation = "Little to no relationship detected between social media and sales"
        }</span>

        <span class="cov0" title="0">if correlation &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Strength:   %s positive correlation\n", strength)
                fmt.Printf("Direction:  üìà Positive (more views ‚Üí more sales)\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Strength:   %s negative correlation\n", strength)
                fmt.Printf("Direction:  üìâ Negative (more views ‚Üí fewer sales)\n")
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n%s\n", interpretation)
        fmt.Println()

        // Recommendations
        fmt.Println("üí° Recommendations")
        fmt.Println(strings.Repeat("‚îÄ", 60))

        if correlation &gt; 0.4 </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ Social media is driving sales! Keep posting consistently.")
                fmt.Println("   ‚Ä¢ Focus on content types with highest engagement")
                fmt.Println("   ‚Ä¢ Increase posting frequency during peak days")
                fmt.Println("   ‚Ä¢ Use top-performing content as templates")
        }</span> else<span class="cov0" title="0"> if correlation &gt; 0.1 </span><span class="cov0" title="0">{
                fmt.Println("‚ö†Ô∏è  Moderate impact. Consider:")
                fmt.Println("   ‚Ä¢ Stronger CTAs in your posts")
                fmt.Println("   ‚Ä¢ More direct product mentions")
                fmt.Println("   ‚Ä¢ Test different content types")
                fmt.Println("   ‚Ä¢ Add Amazon link in bio")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("‚ÑπÔ∏è  Low correlation detected. Possible reasons:")
                fmt.Println("   ‚Ä¢ Need more data (try 60-90 days)")
                fmt.Println("   ‚Ä¢ Delayed conversion effect")
                fmt.Println("   ‚Ä¢ Content not targeted enough")
                fmt.Println("   ‚Ä¢ Audience mismatch")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// aggregateByDay groups data by day
func aggregateByDay(sales []models.BookSale, metrics []models.PostMetric) []models.CorrelationPoint <span class="cov0" title="0">{
        dataMap := make(map[string]*models.CorrelationPoint)

        // Add sales
        for _, sale := range sales </span><span class="cov0" title="0">{
                dateKey := sale.SaleDate.Format("2006-01-02")
                if _, ok := dataMap[dateKey]; !ok </span><span class="cov0" title="0">{
                        dataMap[dateKey] = &amp;models.CorrelationPoint{
                                Date: sale.SaleDate,
                        }
                }</span>
                <span class="cov0" title="0">dataMap[dateKey].UnitsSold += sale.UnitsSold
                dataMap[dateKey].Royalty += sale.Royalty</span>
        }

        // Add metrics
        <span class="cov0" title="0">for _, metric := range metrics </span><span class="cov0" title="0">{
                dateKey := metric.CollectedAt.Format("2006-01-02")
                if _, ok := dataMap[dateKey]; !ok </span><span class="cov0" title="0">{
                        dataMap[dateKey] = &amp;models.CorrelationPoint{
                                Date: metric.CollectedAt,
                        }
                }</span>
                <span class="cov0" title="0">dataMap[dateKey].Views += metric.Views
                dataMap[dateKey].Engagement += metric.EngagementRate</span>
        }

        // Convert to slice
        <span class="cov0" title="0">var points []models.CorrelationPoint
        for _, point := range dataMap </span><span class="cov0" title="0">{
                // Only include days with both metrics and sales
                if point.Views &gt; 0 &amp;&amp; point.UnitsSold &gt; 0 </span><span class="cov0" title="0">{
                        points = append(points, *point)
                }</span>
        }

        <span class="cov0" title="0">return points</span>
}

// calculateCorrelation calculates Pearson correlation coefficient
func calculateCorrelation(data []models.CorrelationPoint) float64 <span class="cov0" title="0">{
        if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">n := float64(len(data))

        var sumX, sumY, sumXY, sumX2, sumY2 float64

        for _, point := range data </span><span class="cov0" title="0">{
                x := float64(point.Views)
                y := float64(point.UnitsSold)

                sumX += x
                sumY += y
                sumXY += x * y
                sumX2 += x * x
                sumY2 += y * y
        }</span>

        <span class="cov0" title="0">numerator := (n * sumXY) - (sumX * sumY)
        denominator := math.Sqrt(((n * sumX2) - (sumX * sumX)) * ((n * sumY2) - (sumY * sumY)))

        if denominator == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return numerator / denominator</span>
}

func sumViews(data []models.CorrelationPoint) int <span class="cov0" title="0">{
        total := 0
        for _, p := range data </span><span class="cov0" title="0">{
                total += p.Views
        }</span>
        <span class="cov0" title="0">return total</span>
}

func sumSales(data []models.CorrelationPoint) int <span class="cov0" title="0">{
        total := 0
        for _, p := range data </span><span class="cov0" title="0">{
                total += p.UnitsSold
        }</span>
        <span class="cov0" title="0">return total</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package stats

import (
        "fmt"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/repository"
        "github.com/spf13/cobra"
)

var (
        period   string
        platform string
)

var showCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show performance analytics dashboard",
        Long: `Display performance analytics and key metrics.

Shows:
  - Total posts published
  - Total views, likes, comments, shares
  - Average engagement rate
  - Top performing posts
  - Platform breakdown`,
        RunE: runShow,
}

func init() <span class="cov0" title="0">{
        showCmd.Flags().StringVar(&amp;period, "period", "30d", "Time period (7d, 30d, 90d, all)")
        showCmd.Flags().StringVar(&amp;platform, "platform", "", "Filter by platform (instagram, tiktok)")
}</span>

func runShow(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("üìä Performance Analytics")
        fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        // Parse period
        var from time.Time
        switch period </span>{
        case "7d":<span class="cov0" title="0">
                from = time.Now().AddDate(0, 0, -7)</span>
        case "30d":<span class="cov0" title="0">
                from = time.Now().AddDate(0, 0, -30)</span>
        case "90d":<span class="cov0" title="0">
                from = time.Now().AddDate(0, 0, -90)</span>
        case "all":<span class="cov0" title="0">
                from = time.Time{}</span> // Zero time = no filter
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid period: %s (use 7d, 30d, 90d, or all)", period)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Period: %s", period)
        if platform != "" </span><span class="cov0" title="0">{
                fmt.Printf(" | Platform: %s", platform)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Get metrics
        metricsRepo := repository.NewMetricsRepository(&amp;cfg.Supabase)
        agg, err := metricsRepo.GetAggregateMetrics(platform, from, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if agg.TotalPosts == 0 </span><span class="cov0" title="0">{
                fmt.Println("No metrics data available.")
                fmt.Println("\nAdd metrics manually or sync from social platforms.")
                return nil
        }</span>

        // Display aggregate metrics
        <span class="cov0" title="0">fmt.Println("üìà Overview")
        fmt.Println(strings.Repeat("‚îÄ", 60))
        fmt.Printf("Total Posts:          %d\n", agg.TotalPosts)
        fmt.Printf("Total Views:          %s\n", formatNumber(agg.TotalViews))
        fmt.Printf("Total Likes:          %s\n", formatNumber(agg.TotalLikes))
        fmt.Printf("Total Comments:       %s\n", formatNumber(agg.TotalComments))
        fmt.Printf("Total Shares:         %s\n", formatNumber(agg.TotalShares))
        fmt.Printf("Avg Engagement Rate:  %.2f%%\n", agg.AvgEngagement)
        fmt.Println()

        // Top performer
        if agg.TopPost != "" </span><span class="cov0" title="0">{
                fmt.Println("üèÜ Top Performer")
                fmt.Println(strings.Repeat("‚îÄ", 60))
                fmt.Printf("Post ID:        %s\n", agg.TopPost[:8])
                fmt.Printf("Engagement:     %.2f%%\n", agg.TopEngagement)
                fmt.Println()
        }</span>

        // Platform breakdown
        <span class="cov0" title="0">if platform == "" </span><span class="cov0" title="0">{
                fmt.Println("üì± Platform Breakdown")
                fmt.Println(strings.Repeat("‚îÄ", 60))

                // Get TikTok metrics
                tiktokAgg, _ := metricsRepo.GetAggregateMetrics("tiktok", from, time.Now())
                fmt.Printf("TikTok:    %d posts | %.2f%% avg engagement\n",
                        tiktokAgg.TotalPosts, tiktokAgg.AvgEngagement)

                // Get Instagram metrics
                igAgg, _ := metricsRepo.GetAggregateMetrics("instagram", from, time.Now())
                fmt.Printf("Instagram: %d posts | %.2f%% avg engagement\n",
                        igAgg.TotalPosts, igAgg.AvgEngagement)
                fmt.Println()
        }</span>

        // Insights
        <span class="cov0" title="0">fmt.Println("üí° Insights")
        fmt.Println(strings.Repeat("‚îÄ", 60))

        avgViewsPerPost := 0
        if agg.TotalPosts &gt; 0 </span><span class="cov0" title="0">{
                avgViewsPerPost = agg.TotalViews / agg.TotalPosts
        }</span>
        <span class="cov0" title="0">fmt.Printf("‚Ä¢ Average views per post: %s\n", formatNumber(avgViewsPerPost))

        if agg.AvgEngagement &gt; 5.0 </span><span class="cov0" title="0">{
                fmt.Println("‚Ä¢ ‚úÖ Excellent engagement rate (&gt;5%)")
        }</span> else<span class="cov0" title="0"> if agg.AvgEngagement &gt; 3.0 </span><span class="cov0" title="0">{
                fmt.Println("‚Ä¢ ‚úÖ Good engagement rate (3-5%)")
        }</span> else<span class="cov0" title="0"> if agg.AvgEngagement &gt; 1.0 </span><span class="cov0" title="0">{
                fmt.Println("‚Ä¢ ‚ö†Ô∏è  Moderate engagement rate (1-3%)")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("‚Ä¢ ‚ö†Ô∏è  Low engagement rate (&lt;1%)")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func formatNumber(n int) string <span class="cov0" title="0">{
        if n &gt;= 1000000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fM", float64(n)/1000000)
        }</span> else<span class="cov0" title="0"> if n &gt;= 1000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fK", float64(n)/1000)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d", n)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package stats

import (
        "github.com/spf13/cobra"
)

// StatsCmd represents the stats command group
var StatsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "View analytics and performance statistics",
        Long: `View performance analytics and insights:
  - Social media metrics dashboard
  - Sales data visualization
  - Social ‚Üí Sales correlation analysis
  - Performance trends`,
}

func init() <span class="cov0" title="0">{
        StatsCmd.AddCommand(showCmd)
        StatsCmd.AddCommand(correlateCmd)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package test

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/ai"
        "github.com/spf13/cobra"
)

var (
        headless bool
)

var geminiCmd = &amp;cobra.Command{
        Use:   "gemini [prompt]",
        Short: "Test Gemini browser automation",
        Long: `Test Gemini browser automation by sending a prompt and retrieving the response.

Example:
  gagipress test gemini "Ciao, come stai?"
  gagipress test gemini --headless=false "Scrivi una storia breve"`,
        Args: cobra.MinimumNArgs(1),
        RunE: runGeminiTest,
}

func init() <span class="cov0" title="0">{
        geminiCmd.Flags().BoolVar(&amp;headless, "headless", true, "Run browser in headless mode")
}</span>

func runGeminiTest(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        prompt := args[0]

        fmt.Println("ü§ñ Testing Gemini browser automation...")
        fmt.Printf("   Prompt: %s\n", prompt)
        fmt.Printf("   Headless: %v\n", headless)
        fmt.Println()

        // Create Gemini client
        client := ai.NewGeminiClient(headless)

        // Send prompt
        fmt.Println("üåê Launching browser...")
        fmt.Println("üìù Sending prompt to Gemini...")
        fmt.Println("‚è≥ Waiting for response (this may take a few seconds)...")
        fmt.Println()

        response, err := client.GenerateText(prompt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Gemini test failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Response received!")
        fmt.Println()
        fmt.Println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        fmt.Println(response)
        fmt.Println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package test

import (
        "github.com/spf13/cobra"
)

// TestCmd represents the test command group
var TestCmd = &amp;cobra.Command{
        Use:   "test",
        Short: "Test various integrations and features",
        Long:  `Test command group for testing browser automation, APIs, and other features.`,
}

func init() <span class="cov0" title="0">{
        TestCmd.AddCommand(geminiCmd)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

const (
        Version   = "0.1.0"
        BuildDate = "2026-02-08"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of Gagipress CLI",
        Long:  `Display the current version and build information of Gagipress CLI.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("Gagipress CLI v%s (built %s)\n", Version, BuildDate)
                fmt.Println("https://github.com/gagipress/gagipress-cli")
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package ai

import (
        "context"
        "fmt"
        "time"

        "github.com/chromedp/chromedp"
)

// GeminiClient handles browser automation for Gemini
type GeminiClient struct {
        headless bool
}

// NewGeminiClient creates a new Gemini browser automation client
func NewGeminiClient(headless bool) *GeminiClient <span class="cov0" title="0">{
        return &amp;GeminiClient{
                headless: headless,
        }
}</span>

// GenerateText sends a prompt to Gemini and retrieves the response
func (g *GeminiClient) GenerateText(prompt string) (string, error) <span class="cov0" title="0">{
        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
        defer cancel()

        // Setup browser options
        opts := append(chromedp.DefaultExecAllocatorOptions[:],
                chromedp.Flag("headless", g.headless),
                chromedp.Flag("disable-blink-features", "AutomationControlled"),
                chromedp.UserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"),
        )

        allocCtx, allocCancel := chromedp.NewExecAllocator(ctx, opts...)
        defer allocCancel()

        // Create browser context
        browserCtx, browserCancel := chromedp.NewContext(allocCtx)
        defer browserCancel()

        var response string

        // Automate browser interaction
        err := chromedp.Run(browserCtx,
                // Navigate to Gemini
                chromedp.Navigate("https://gemini.google.com"),

                // Wait for page to load
                chromedp.WaitVisible(`textarea[placeholder*="Enter a prompt"]`, chromedp.ByQuery),
                chromedp.Sleep(2*time.Second),

                // Enter prompt
                chromedp.SendKeys(`textarea[placeholder*="Enter a prompt"]`, prompt, chromedp.ByQuery),
                chromedp.Sleep(500*time.Millisecond),

                // Submit (press Enter)
                chromedp.SendKeys(`textarea[placeholder*="Enter a prompt"]`, "\n", chromedp.ByQuery),

                // Wait for response (this is a placeholder - actual selector depends on Gemini's UI)
                chromedp.Sleep(5*time.Second),
                chromedp.WaitVisible(`div[data-test-id="conversation-turn-2"]`, chromedp.ByQuery),

                // Extract response text
                chromedp.Text(`div[data-test-id="conversation-turn-2"]`, &amp;response, chromedp.ByQuery),
        )

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("browser automation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if response == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("empty response from Gemini")
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

// TestConnection tests the Gemini browser automation
func (g *GeminiClient) TestConnection() error <span class="cov0" title="0">{
        _, err := g.GenerateText("Say 'OK' if you can read this.")
        return err
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package ai

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
)

// OpenAIClient wraps OpenAI API interactions
type OpenAIClient struct {
        apiKey     string
        model      string
        httpClient *http.Client
        baseURL    string
}

// ChatMessage represents a message in the conversation
type ChatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// ChatCompletionRequest represents the request to OpenAI API
type ChatCompletionRequest struct {
        Model       string        `json:"model"`
        Messages    []ChatMessage `json:"messages"`
        Temperature float64       `json:"temperature,omitempty"`
        MaxTokens   int           `json:"max_tokens,omitempty"`
}

// ChatCompletionResponse represents the response from OpenAI API
type ChatCompletionResponse struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index   int         `json:"index"`
                Message ChatMessage `json:"message"`
                Finish  string      `json:"finish_reason"`
        } `json:"choices"`
        Usage struct {
                PromptTokens     int `json:"prompt_tokens"`
                CompletionTokens int `json:"completion_tokens"`
                TotalTokens      int `json:"total_tokens"`
        } `json:"usage"`
}

// ErrorResponse represents an error from OpenAI API
type ErrorResponse struct {
        Error struct {
                Message string `json:"message"`
                Type    string `json:"type"`
                Code    string `json:"code"`
        } `json:"error"`
}

// NewOpenAIClient creates a new OpenAI client
func NewOpenAIClient(cfg *config.OpenAIConfig) *OpenAIClient <span class="cov0" title="0">{
        model := cfg.Model
        if model == "" </span><span class="cov0" title="0">{
                model = "gpt-4o-mini" // default model
        }</span>

        <span class="cov0" title="0">return &amp;OpenAIClient{
                apiKey:  cfg.APIKey,
                model:   model,
                baseURL: "https://api.openai.com/v1",
                httpClient: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }</span>
}

// ChatCompletion sends a chat completion request with retry logic
func (c *OpenAIClient) ChatCompletion(messages []ChatMessage, temperature float64, maxTokens int) (*ChatCompletionResponse, error) <span class="cov0" title="0">{
        req := ChatCompletionRequest{
                Model:       c.model,
                Messages:    messages,
                Temperature: temperature,
                MaxTokens:   maxTokens,
        }

        var resp *ChatCompletionResponse
        var err error

        // Retry logic with exponential backoff
        maxRetries := 3
        for attempt := 0; attempt &lt; maxRetries; attempt++ </span><span class="cov0" title="0">{
                resp, err = c.makeRequest(req)
                if err == nil </span><span class="cov0" title="0">{
                        return resp, nil
                }</span>

                // Don't retry on client errors (4xx), only on server errors (5xx) and network errors
                <span class="cov0" title="0">if httpErr, ok := err.(*HTTPError); ok &amp;&amp; httpErr.StatusCode &lt; 500 </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Exponential backoff: 1s, 2s, 4s
                <span class="cov0" title="0">if attempt &lt; maxRetries-1 </span><span class="cov0" title="0">{
                        backoff := time.Duration(1&lt;&lt;uint(attempt)) * time.Second
                        time.Sleep(backoff)
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed after %d retries: %w", maxRetries, err)</span>
}

// makeRequest performs the actual HTTP request to OpenAI API
func (c *OpenAIClient) makeRequest(req ChatCompletionRequest) (*ChatCompletionResponse, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequest("POST", c.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Authorization", "Bearer "+c.apiKey)

        httpResp, err := c.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer httpResp.Body.Close()

        body, err := io.ReadAll(httpResp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Check for HTTP errors
        <span class="cov0" title="0">if httpResp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;HTTPError{
                                StatusCode: httpResp.StatusCode,
                                Message:    string(body),
                        }
                }</span>
                <span class="cov0" title="0">return nil, &amp;HTTPError{
                        StatusCode: httpResp.StatusCode,
                        Message:    errResp.Error.Message,
                }</span>
        }

        <span class="cov0" title="0">var resp ChatCompletionResponse
        if err := json.Unmarshal(body, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GenerateText is a convenience method for simple text generation
func (c *OpenAIClient) GenerateText(prompt string, temperature float64) (string, error) <span class="cov0" title="0">{
        messages := []ChatMessage{
                {
                        Role:    "user",
                        Content: prompt,
                },
        }

        resp, err := c.ChatCompletion(messages, temperature, 2000)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(resp.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from OpenAI")
        }</span>

        <span class="cov0" title="0">return resp.Choices[0].Message.Content, nil</span>
}

// TestConnection tests the OpenAI API connection
func (c *OpenAIClient) TestConnection() error <span class="cov0" title="0">{
        _, err := c.GenerateText("Say 'OK' if you can read this.", 0.0)
        return err
}</span>

// HTTPError represents an HTTP error from the API
type HTTPError struct {
        StatusCode int
        Message    string
}

func (e *HTTPError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
        Supabase  SupabaseConfig  `mapstructure:"supabase"`
        OpenAI    OpenAIConfig    `mapstructure:"openai"`
        Instagram InstagramConfig `mapstructure:"instagram"`
        TikTok    TikTokConfig    `mapstructure:"tiktok"`
        Amazon    AmazonConfig    `mapstructure:"amazon"`
}

// SupabaseConfig holds Supabase connection details
type SupabaseConfig struct {
        URL        string `mapstructure:"url"`
        AnonKey    string `mapstructure:"anon_key"`
        ServiceKey string `mapstructure:"service_key"`
}

// OpenAIConfig holds OpenAI API configuration
type OpenAIConfig struct {
        APIKey string `mapstructure:"api_key"`
        Model  string `mapstructure:"model"`
}

// InstagramConfig holds Instagram API configuration
type InstagramConfig struct {
        AccessToken string `mapstructure:"access_token"`
        AccountID   string `mapstructure:"account_id"`
}

// TikTokConfig holds TikTok API configuration
type TikTokConfig struct {
        AccessToken string `mapstructure:"access_token"`
        AccountID   string `mapstructure:"account_id"`
}

// AmazonConfig holds Amazon KDP credentials
type AmazonConfig struct {
        Email    string `mapstructure:"email"`
        Password string `mapstructure:"password"`
}

// Load loads configuration from file
func Load() (*Config, error) <span class="cov0" title="0">{
        var cfg Config
        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode config: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// Save saves configuration to file
func Save(cfg *Config) error <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">configDir := filepath.Join(home, ".gagipress")
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">configFile := filepath.Join(configDir, "config.yaml")

        viper.Set("supabase", cfg.Supabase)
        viper.Set("openai", cfg.OpenAI)
        viper.Set("instagram", cfg.Instagram)
        viper.Set("tiktok", cfg.TikTok)
        viper.Set("amazon", cfg.Amazon)

        if err := viper.WriteConfigAs(configFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Supabase.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("supabase URL is required")
        }</span>
        <span class="cov0" title="0">if c.Supabase.AnonKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("supabase anon key is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsConfigured checks if the application is configured
func IsConfigured() bool <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">configFile := filepath.Join(home, ".gagipress", "config.yaml")
        _, err = os.Stat(configFile)
        return err == nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package errors

import (
        "fmt"
)

// ErrorType represents the category of error
type ErrorType string

const (
        ErrorTypeValidation ErrorType = "validation"
        ErrorTypeAPI        ErrorType = "api"
        ErrorTypeDatabase   ErrorType = "database"
        ErrorTypeNotFound   ErrorType = "not_found"
        ErrorTypeNetwork    ErrorType = "network"
)

// AppError represents an application error with context
type AppError struct {
        Type    ErrorType
        Message string
        Err     error
}

func (e *AppError) Error() string <span class="cov3" title="2">{
        if e.Err != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s: %s: %v", e.Type, e.Message, e.Err)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: %s", e.Type, e.Message)</span>
}

func (e *AppError) Unwrap() error <span class="cov3" title="2">{
        return e.Err
}</span>

// New creates a new AppError
func New(errType ErrorType, message string) *AppError <span class="cov6" title="4">{
        return &amp;AppError{
                Type:    errType,
                Message: message,
        }
}</span>

// Wrap wraps an existing error with context
func Wrap(err error, errType ErrorType, message string) *AppError <span class="cov3" title="2">{
        return &amp;AppError{
                Type:    errType,
                Message: message,
                Err:     err,
        }
}</span>

// IsType checks if error is of specific type
func IsType(err error, errType ErrorType) bool <span class="cov10" title="12">{
        appErr, ok := err.(*AppError)
        if !ok </span><span class="cov8" title="9">{
                return false
        }</span>
        <span class="cov4" title="3">return appErr.Type == errType</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package errors

import (
        "context"
        "math"
        "time"
)

// RetryConfig configures retry behavior
type RetryConfig struct {
        MaxAttempts int
        InitialWait time.Duration
        MaxWait     time.Duration
        Multiplier  float64
}

// DefaultRetryConfig returns sensible defaults
func DefaultRetryConfig() RetryConfig <span class="cov1" title="1">{
        return RetryConfig{
                MaxAttempts: 3,
                InitialWait: 1 * time.Second,
                MaxWait:     30 * time.Second,
                Multiplier:  2.0,
        }
}</span>

// Retry executes fn with exponential backoff
func Retry(ctx context.Context, config RetryConfig, fn func() error) error <span class="cov7" title="5">{
        var lastErr error

        for attempt := 0; attempt &lt; config.MaxAttempts; attempt++ </span><span class="cov10" title="10">{
                err := fn()
                if err == nil </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov9" title="9">lastErr = err

                // Don't retry validation errors
                if IsType(err, ErrorTypeValidation) </span><span class="cov1" title="1">{
                        return err
                }</span>

                // Don't wait after last attempt
                <span class="cov9" title="8">if attempt == config.MaxAttempts-1 </span><span class="cov3" title="2">{
                        break</span>
                }

                // Calculate wait time with exponential backoff
                <span class="cov8" title="6">waitTime := time.Duration(float64(config.InitialWait) * math.Pow(config.Multiplier, float64(attempt)))
                if waitTime &gt; config.MaxWait </span><span class="cov0" title="0">{
                        waitTime = config.MaxWait
                }</span>

                // Wait with context cancellation support
                <span class="cov8" title="6">select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                case &lt;-time.After(waitTime):<span class="cov7" title="5"></span>
                }
        }

        <span class="cov3" title="2">return lastErr</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package generator

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/ai"
        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/errors"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/prompts"
        "github.com/gagipress/gagipress-cli/internal/repository"
)

// IdeaGenerator generates content ideas using AI
type IdeaGenerator struct {
        openaiClient  *ai.OpenAIClient
        geminiClient  *ai.GeminiClient
        contentRepo   *repository.ContentRepository
        useGemini     bool
        geminiHeadless bool
}

// NewIdeaGenerator creates a new idea generator
func NewIdeaGenerator(cfg *config.Config, useGemini bool) *IdeaGenerator <span class="cov0" title="0">{
        return &amp;IdeaGenerator{
                openaiClient:   ai.NewOpenAIClient(&amp;cfg.OpenAI),
                geminiClient:   ai.NewGeminiClient(true), // headless by default
                contentRepo:    repository.NewContentRepository(&amp;cfg.Supabase),
                useGemini:      useGemini,
                geminiHeadless: true,
        }
}</span>

// GeneratedIdea represents a generated content idea from AI
type GeneratedIdea struct {
        Type           string `json:"type"`
        Title          string `json:"title"`
        Description    string `json:"description"`
        Hook           string `json:"hook"`
        CTA            string `json:"cta"`
        RelevanceScore int    `json:"relevance_score"`
}

// GenerateIdeas generates content ideas for a book
func (g *IdeaGenerator) GenerateIdeas(bookTitle, genre, targetAudience string, niche prompts.BookNiche, count int) ([]GeneratedIdea, error) <span class="cov0" title="0">{
        // Build prompt
        prompt := prompts.IdeaPromptTemplate(bookTitle, genre, targetAudience, niche, count)

        var responseText string
        var err error

        ctx := context.Background()

        // Try OpenAI first with retry logic unless explicitly using Gemini
        if !g.useGemini </span><span class="cov0" title="0">{
                fmt.Println("ü§ñ Using OpenAI for generation...")

                retryErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                        responseText, err = g.openaiClient.GenerateText(prompt, 0.8)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, errors.ErrorTypeAPI, "OpenAI API call failed")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">if retryErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  OpenAI failed after retries: %v\n", retryErr)
                        fmt.Println("üîÑ Falling back to Gemini...")
                        g.useGemini = true
                }</span>
        }

        // Fallback to Gemini if OpenAI failed or explicitly requested
        <span class="cov0" title="0">if g.useGemini </span><span class="cov0" title="0">{
                fmt.Println("ü§ñ Using Gemini for generation...")
                responseText, err = g.geminiClient.GenerateText(prompt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.ErrorTypeAPI, "both OpenAI and Gemini failed")
                }</span>
        }

        // Parse JSON response
        <span class="cov0" title="0">ideas, err := g.parseIdeasFromResponse(responseText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ErrorTypeValidation, "failed to parse AI response")
        }</span>

        <span class="cov0" title="0">return ideas, nil</span>
}

// parseIdeasFromResponse parses the AI response into structured ideas
func (g *IdeaGenerator) parseIdeasFromResponse(response string) ([]GeneratedIdea, error) <span class="cov0" title="0">{
        // Extract JSON array from response (AI might add text around it)
        start := strings.Index(response, "[")
        end := strings.LastIndex(response, "]")

        if start == -1 || end == -1 || start &gt; end </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no JSON array found in response")
        }</span>

        <span class="cov0" title="0">jsonStr := response[start : end+1]

        var ideas []GeneratedIdea
        if err := json.Unmarshal([]byte(jsonStr), &amp;ideas); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return ideas, nil</span>
}

// SaveIdeas saves generated ideas to the database
func (g *IdeaGenerator) SaveIdeas(ideas []GeneratedIdea, bookID *string) ([]models.ContentIdea, error) <span class="cov0" title="0">{
        var savedIdeas []models.ContentIdea

        for _, idea := range ideas </span><span class="cov0" title="0">{
                input := &amp;models.ContentIdeaInput{
                        Type:             idea.Type,
                        BriefDescription: idea.Title + ": " + idea.Description,
                        RelevanceScore:   &amp;idea.RelevanceScore,
                        BookID:           bookID,
                        Metadata: map[string]string{
                                "hook": idea.Hook,
                                "cta":  idea.CTA,
                        },
                }

                if err := input.Validate(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Skipping invalid idea: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">savedIdea, err := g.contentRepo.CreateIdea(input)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Failed to save idea: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">savedIdeas = append(savedIdeas, *savedIdea)</span>
        }

        <span class="cov0" title="0">return savedIdeas, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package generator

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/ai"
        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/errors"
        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/prompts"
        "github.com/gagipress/gagipress-cli/internal/repository"
)

// ScriptGenerator generates content scripts from ideas
type ScriptGenerator struct {
        openaiClient *ai.OpenAIClient
        geminiClient *ai.GeminiClient
        contentRepo  *repository.ContentRepository
        useGemini    bool
}

// NewScriptGenerator creates a new script generator
func NewScriptGenerator(cfg *config.Config, useGemini bool) *ScriptGenerator <span class="cov0" title="0">{
        return &amp;ScriptGenerator{
                openaiClient: ai.NewOpenAIClient(&amp;cfg.OpenAI),
                geminiClient: ai.NewGeminiClient(true),
                contentRepo:  repository.NewContentRepository(&amp;cfg.Supabase),
                useGemini:    useGemini,
        }
}</span>

// GeneratedScript represents a generated script from AI
type GeneratedScript struct {
        Hook            string   `json:"hook"`
        MainContent     string   `json:"main_content"`
        CTA             string   `json:"cta"`
        Hashtags        []string `json:"hashtags"`
        MusicSuggestion string   `json:"music_suggestion"`
        VideoNotes      string   `json:"video_notes"`
        EstimatedLength int      `json:"estimated_length"`
}

// GenerateScript generates a complete script from an idea
func (g *ScriptGenerator) GenerateScript(idea *models.ContentIdea, bookTitle, platform string) (*GeneratedScript, error) <span class="cov0" title="0">{
        // Build prompt
        ideaDescription := idea.BriefDescription
        prompt := prompts.ScriptPromptTemplate(ideaDescription, bookTitle, platform)

        var responseText string
        var err error

        ctx := context.Background()

        // Try OpenAI first with retry logic unless explicitly using Gemini
        if !g.useGemini </span><span class="cov0" title="0">{
                fmt.Println("ü§ñ Using OpenAI for script generation...")

                retryErr := errors.Retry(ctx, errors.DefaultRetryConfig(), func() error </span><span class="cov0" title="0">{
                        responseText, err = g.openaiClient.GenerateText(prompt, 0.7)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, errors.ErrorTypeAPI, "OpenAI API call failed")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">if retryErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  OpenAI failed after retries: %v\n", retryErr)
                        fmt.Println("üîÑ Falling back to Gemini...")
                        g.useGemini = true
                }</span>
        }

        // Fallback to Gemini if OpenAI failed or explicitly requested
        <span class="cov0" title="0">if g.useGemini </span><span class="cov0" title="0">{
                fmt.Println("ü§ñ Using Gemini for script generation...")
                responseText, err = g.geminiClient.GenerateText(prompt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.ErrorTypeAPI, "both OpenAI and Gemini failed")
                }</span>
        }

        // Parse JSON response
        <span class="cov0" title="0">script, err := g.parseScriptFromResponse(responseText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ErrorTypeValidation, "failed to parse AI response")
        }</span>

        <span class="cov0" title="0">return script, nil</span>
}

// parseScriptFromResponse parses the AI response into a structured script
func (g *ScriptGenerator) parseScriptFromResponse(response string) (*GeneratedScript, error) <span class="cov0" title="0">{
        // Extract JSON object from response
        start := strings.Index(response, "{")
        end := strings.LastIndex(response, "}")

        if start == -1 || end == -1 || start &gt; end </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no JSON object found in response")
        }</span>

        <span class="cov0" title="0">jsonStr := response[start : end+1]

        var script GeneratedScript
        if err := json.Unmarshal([]byte(jsonStr), &amp;script); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if script.Hook == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required field: hook")
        }</span>
        <span class="cov0" title="0">if script.MainContent == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required field: main_content")
        }</span>
        <span class="cov0" title="0">if script.CTA == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing required field: cta")
        }</span>

        // Set defaults if missing
        <span class="cov0" title="0">if script.EstimatedLength == 0 </span><span class="cov0" title="0">{
                script.EstimatedLength = 45 // default 45 seconds
        }</span>
        <span class="cov0" title="0">if len(script.Hashtags) == 0 </span><span class="cov0" title="0">{
                script.Hashtags = []string{"#booktok", "#bookstagram"} // minimal defaults
        }</span>

        <span class="cov0" title="0">return &amp;script, nil</span>
}

// SaveScript saves generated script to the database
func (g *ScriptGenerator) SaveScript(script *GeneratedScript, ideaID string, format string) (*models.ContentScript, error) <span class="cov0" title="0">{
        input := &amp;models.ContentScriptInput{
                IdeaID:          ideaID,
                Hook:            script.Hook,
                MainContent:     script.MainContent,
                CTA:             script.CTA,
                Hashtags:        script.Hashtags,
                EstimatedLength: script.EstimatedLength,
                Format:          format,
        }

        if err := input.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">savedScript, err := g.contentRepo.CreateScript(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save script: %w", err)
        }</span>

        // Update idea status to "scripted"
        <span class="cov0" title="0">if err := g.contentRepo.UpdateIdeaStatus(ideaID, "scripted"); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Warning: failed to update idea status: %v\n", err)
        }</span>

        <span class="cov0" title="0">return savedScript, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package models

import (
        "time"
)

// Book represents a book in the catalog
type Book struct {
        ID              string     `json:"id"`
        Title           string     `json:"title"`
        Genre           string     `json:"genre"`
        TargetAudience  string     `json:"target_audience,omitempty"`
        KDPASIN         string     `json:"kdp_asin,omitempty"`
        CoverImageURL   string     `json:"cover_image_url,omitempty"`
        PublicationDate *time.Time `json:"publication_date,omitempty"`
        CurrentRank     *int       `json:"current_rank,omitempty"`
        TotalSales      int        `json:"total_sales"`
        CreatedAt       time.Time  `json:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at"`
}

// BookInput represents input for creating/updating a book
type BookInput struct {
        Title           string     `json:"title"`
        Genre           string     `json:"genre"`
        TargetAudience  string     `json:"target_audience,omitempty"`
        KDPASIN         string     `json:"kdp_asin,omitempty"`
        CoverImageURL   string     `json:"cover_image_url,omitempty"`
        PublicationDate *time.Time `json:"publication_date,omitempty"`
}

// Validate validates book input
func (b *BookInput) Validate() error <span class="cov10" title="3">{
        if b.Title == "" </span><span class="cov1" title="1">{
                return ErrInvalidInput{Field: "title", Message: "title is required"}
        }</span>
        <span class="cov6" title="2">if b.Genre == "" </span><span class="cov1" title="1">{
                return ErrInvalidInput{Field: "genre", Message: "genre is required"}
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ErrInvalidInput represents a validation error
type ErrInvalidInput struct {
        Field   string
        Message string
}

func (e ErrInvalidInput) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

import (
        "time"
)

// ContentIdea represents a content idea
type ContentIdea struct {
        ID               string    `json:"id"`
        Type             string    `json:"type"` // educational, entertainment, bts, ugc, trend
        BriefDescription string    `json:"brief_description"`
        RelevanceScore   *int      `json:"relevance_score,omitempty"`
        BookID           *string   `json:"book_id,omitempty"`
        Status           string    `json:"status"` // pending, approved, rejected, scripted
        GeneratedAt      time.Time `json:"generated_at"`
        Metadata         any       `json:"metadata,omitempty"` // JSONB field
}

// ContentIdeaInput represents input for creating a content idea
type ContentIdeaInput struct {
        Type             string  `json:"type"`
        BriefDescription string  `json:"brief_description"`
        RelevanceScore   *int    `json:"relevance_score,omitempty"`
        BookID           *string `json:"book_id,omitempty"`
        Metadata         any     `json:"metadata,omitempty"`
}

// Validate validates content idea input
func (c *ContentIdeaInput) Validate() error <span class="cov10" title="4">{
        if c.Type == "" </span><span class="cov1" title="1">{
                return ErrInvalidInput{Field: "type", Message: "type is required"}
        }</span>
        <span class="cov8" title="3">validTypes := map[string]bool{
                "educational":   true,
                "entertainment": true,
                "bts":           true,
                "ugc":           true,
                "trend":         true,
        }
        if !validTypes[c.Type] </span><span class="cov1" title="1">{
                return ErrInvalidInput{Field: "type", Message: "invalid type"}
        }</span>
        <span class="cov5" title="2">if c.BriefDescription == "" </span><span class="cov1" title="1">{
                return ErrInvalidInput{Field: "brief_description", Message: "brief description is required"}
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ContentScript represents a generated script
type ContentScript struct {
        ID              string    `json:"id"`
        IdeaID          string    `json:"idea_id"`
        Hook            string    `json:"hook"`
        MainContent     string    `json:"main_content"`
        CTA             string    `json:"cta"`
        Hashtags        []string  `json:"hashtags,omitempty"`
        EstimatedLength int       `json:"estimated_length"` // seconds
        Format          string    `json:"format"`           // vertical, square
        ScriptedAt      time.Time `json:"scripted_at"`
}

// ContentScriptInput represents input for creating a script
type ContentScriptInput struct {
        IdeaID          string   `json:"idea_id"`
        Hook            string   `json:"hook"`
        MainContent     string   `json:"main_content"`
        CTA             string   `json:"cta"`
        Hashtags        []string `json:"hashtags,omitempty"`
        EstimatedLength int      `json:"estimated_length"`
        Format          string   `json:"format"`
}

// Validate validates content script input
func (c *ContentScriptInput) Validate() error <span class="cov0" title="0">{
        if c.IdeaID == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "idea_id", Message: "idea ID is required"}
        }</span>
        <span class="cov0" title="0">if c.Hook == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "hook", Message: "hook is required"}
        }</span>
        <span class="cov0" title="0">if c.MainContent == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "main_content", Message: "main content is required"}
        }</span>
        <span class="cov0" title="0">if c.CTA == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "cta", Message: "CTA is required"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ContentCalendar represents a scheduled post
type ContentCalendar struct {
        ID           string     `json:"id"`
        ScriptID     *string    `json:"script_id,omitempty"`
        ScheduledFor time.Time  `json:"scheduled_for"`
        Platform     string     `json:"platform"` // instagram, tiktok
        Status       string     `json:"status"`   // pending_approval, approved, published, failed
        PublishedAt  *time.Time `json:"published_at,omitempty"`
        ErrorMessage *string    `json:"error_message,omitempty"`
}

// ContentCalendarInput represents input for creating a calendar entry
type ContentCalendarInput struct {
        ScriptID     *string   `json:"script_id,omitempty"`
        ScheduledFor time.Time `json:"scheduled_for"`
        Platform     string    `json:"platform"`
}

// Validate validates content calendar input
func (c *ContentCalendarInput) Validate() error <span class="cov0" title="0">{
        if c.ScheduledFor.IsZero() </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "scheduled_for", Message: "scheduled time is required"}
        }</span>
        <span class="cov0" title="0">if c.Platform != "instagram" &amp;&amp; c.Platform != "tiktok" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "platform", Message: "platform must be 'instagram' or 'tiktok'"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package models

import (
        "time"
)

// PostMetric represents performance metrics for a published post
type PostMetric struct {
        ID             string    `json:"id"`
        CalendarID     string    `json:"calendar_id"`
        Platform       string    `json:"platform"`
        Views          int       `json:"views"`
        Likes          int       `json:"likes"`
        Comments       int       `json:"comments"`
        Shares         int       `json:"shares"`
        Saves          int       `json:"saves"`
        EngagementRate float64   `json:"engagement_rate"`
        CollectedAt    time.Time `json:"collected_at"`
}

// PostMetricInput represents input for creating a post metric
type PostMetricInput struct {
        CalendarID string  `json:"calendar_id"`
        Platform   string  `json:"platform"`
        Views      int     `json:"views"`
        Likes      int     `json:"likes"`
        Comments   int     `json:"comments"`
        Shares     int     `json:"shares"`
        Saves      int     `json:"saves"`
}

// Validate validates post metric input
func (p *PostMetricInput) Validate() error <span class="cov0" title="0">{
        if p.CalendarID == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "calendar_id", Message: "calendar ID is required"}
        }</span>
        <span class="cov0" title="0">if p.Platform != "instagram" &amp;&amp; p.Platform != "tiktok" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "platform", Message: "platform must be 'instagram' or 'tiktok'"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CalculateEngagementRate calculates engagement rate for the metric
func (p *PostMetricInput) CalculateEngagementRate() float64 <span class="cov10" title="3">{
        if p.Views == 0 </span><span class="cov1" title="1">{
                return 0.0
        }</span>
        <span class="cov6" title="2">totalEngagement := p.Likes + p.Comments + p.Shares + p.Saves
        return float64(totalEngagement) / float64(p.Views) * 100.0</span>
}

// AggregateMetrics represents aggregated metrics for a period
type AggregateMetrics struct {
        TotalPosts     int     `json:"total_posts"`
        TotalViews     int     `json:"total_views"`
        TotalLikes     int     `json:"total_likes"`
        TotalComments  int     `json:"total_comments"`
        TotalShares    int     `json:"total_shares"`
        AvgEngagement  float64 `json:"avg_engagement"`
        TopPost        string  `json:"top_post,omitempty"`
        TopEngagement  float64 `json:"top_engagement"`
}

// CorrelationPoint represents a data point for correlation analysis
type CorrelationPoint struct {
        Date        time.Time `json:"date"`
        Views       int       `json:"views"`
        Engagement  float64   `json:"engagement"`
        UnitsSold   int       `json:"units_sold"`
        Royalty     float64   `json:"royalty"`
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package models

import (
        "time"
)

// BookSale represents a daily sales record for a book
type BookSale struct {
        ID         string    `json:"id"`
        BookID     string    `json:"book_id"`
        SaleDate   time.Time `json:"sale_date"`
        UnitsSold  int       `json:"units_sold"`
        Royalty    float64   `json:"royalty"`
        PageReads  int       `json:"page_reads"`
        CreatedAt  time.Time `json:"created_at"`
}

// BookSaleInput represents input for creating a book sale record
type BookSaleInput struct {
        BookID    string    `json:"book_id"`
        SaleDate  time.Time `json:"sale_date"`
        UnitsSold int       `json:"units_sold"`
        Royalty   float64   `json:"royalty"`
        PageReads int       `json:"page_reads"`
}

// Validate validates book sale input
func (b *BookSaleInput) Validate() error <span class="cov0" title="0">{
        if b.BookID == "" </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "book_id", Message: "book ID is required"}
        }</span>
        <span class="cov0" title="0">if b.SaleDate.IsZero() </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "sale_date", Message: "sale date is required"}
        }</span>
        <span class="cov0" title="0">if b.UnitsSold &lt; 0 </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "units_sold", Message: "units sold cannot be negative"}
        }</span>
        <span class="cov0" title="0">if b.Royalty &lt; 0 </span><span class="cov0" title="0">{
                return ErrInvalidInput{Field: "royalty", Message: "royalty cannot be negative"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// KDPReportRow represents a row from Amazon KDP sales report CSV
type KDPReportRow struct {
        Title        string
        ASIN         string
        OrderDate    time.Time
        UnitsSold    int
        Royalty      float64
        PageReads    int
        Marketplace  string
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package parser

import (
        "encoding/csv"
        "fmt"
        "io"
        "strconv"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/models"
)

// KDPParser parses Amazon KDP sales reports
type KDPParser struct{}

// NewKDPParser creates a new KDP parser
func NewKDPParser() *KDPParser <span class="cov3" title="4">{
        return &amp;KDPParser{}
}</span>

// ParseCSV parses a KDP CSV file
func (p *KDPParser) ParseCSV(reader io.Reader) ([]models.KDPReportRow, error) <span class="cov5" title="16">{
        csvReader := csv.NewReader(reader)
        csvReader.TrimLeadingSpace = true

        // Read header
        header, err := csvReader.Read()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read CSV header: %w", err)
        }</span>

        // Map column names to indices
        <span class="cov5" title="15">colMap := make(map[string]int)
        for i, col := range header </span><span class="cov7" title="48">{
                colMap[strings.ToLower(strings.TrimSpace(col))] = i
        }</span>

        // Required columns (flexible column names for different KDP report formats)
        <span class="cov5" title="15">titleCol := p.findColumn(colMap, "title", "book title", "product")
        asinCol := p.findColumn(colMap, "asin", "asin/isbn")
        dateCol := p.findColumn(colMap, "date", "order date", "transaction date", "sale date")
        unitsCol := p.findColumn(colMap, "units sold", "units", "quantity")
        royaltyCol := p.findColumn(colMap, "royalty", "net units sold", "earnings")
        pageReadsCol := p.findColumn(colMap, "kenp read", "pages read", "page reads")

        if titleCol == -1 || dateCol == -1 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("required columns not found (need at least: title, date)")
        }</span>

        <span class="cov5" title="14">var rows []models.KDPReportRow

        // Read data rows
        for </span><span class="cov6" title="30">{
                record, err := csvReader.Read()
                if err == io.EOF </span><span class="cov5" title="14">{
                        break</span>
                }
                <span class="cov5" title="16">if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: skipping malformed row: %v\n", err)
                        continue</span>
                }

                // Parse row
                <span class="cov5" title="16">row := models.KDPReportRow{}

                // Title (required)
                if titleCol &gt;= 0 &amp;&amp; titleCol &lt; len(record) </span><span class="cov5" title="16">{
                        row.Title = strings.TrimSpace(record[titleCol])
                }</span>

                // ASIN (optional)
                <span class="cov5" title="16">if asinCol &gt;= 0 &amp;&amp; asinCol &lt; len(record) </span><span class="cov3" title="5">{
                        row.ASIN = strings.TrimSpace(record[asinCol])
                }</span>

                // Date (required)
                <span class="cov5" title="16">if dateCol &gt;= 0 &amp;&amp; dateCol &lt; len(record) </span><span class="cov5" title="16">{
                        dateStr := strings.TrimSpace(record[dateCol])
                        // Try multiple date formats
                        formats := []string{
                                "2006-01-02",
                                "01/02/2006",
                                "02/01/2006",
                                "2006/01/02",
                        }
                        var parsed bool
                        for _, format := range formats </span><span class="cov6" title="26">{
                                if t, err := time.Parse(format, dateStr); err == nil </span><span class="cov5" title="15">{
                                        row.OrderDate = t
                                        parsed = true
                                        break</span>
                                }
                        }
                        <span class="cov5" title="16">if !parsed </span><span class="cov1" title="1">{
                                fmt.Printf("Warning: could not parse date '%s', skipping row\n", dateStr)
                                continue</span>
                        }
                }

                // Units sold (optional)
                <span class="cov5" title="15">if unitsCol &gt;= 0 &amp;&amp; unitsCol &lt; len(record) </span><span class="cov3" title="5">{
                        unitsStr := strings.TrimSpace(record[unitsCol])
                        if units, err := strconv.Atoi(unitsStr); err == nil </span><span class="cov3" title="5">{
                                row.UnitsSold = units
                        }</span>
                }

                // Royalty (optional)
                <span class="cov5" title="15">if royaltyCol &gt;= 0 &amp;&amp; royaltyCol &lt; len(record) </span><span class="cov5" title="10">{
                        royaltyStr := strings.TrimSpace(record[royaltyCol])
                        // Remove currency symbols
                        royaltyStr = strings.ReplaceAll(royaltyStr, "$", "")
                        royaltyStr = strings.ReplaceAll(royaltyStr, "‚Ç¨", "")
                        royaltyStr = strings.ReplaceAll(royaltyStr, ",", "")
                        if royalty, err := strconv.ParseFloat(royaltyStr, 64); err == nil </span><span class="cov5" title="10">{
                                row.Royalty = royalty
                        }</span>
                }

                // Page reads (optional)
                <span class="cov5" title="15">if pageReadsCol &gt;= 0 &amp;&amp; pageReadsCol &lt; len(record) </span><span class="cov1" title="1">{
                        pageReadsStr := strings.TrimSpace(record[pageReadsCol])
                        pageReadsStr = strings.ReplaceAll(pageReadsStr, ",", "")
                        if pageReads, err := strconv.Atoi(pageReadsStr); err == nil </span><span class="cov1" title="1">{
                                row.PageReads = pageReads
                        }</span>
                }

                <span class="cov5" title="15">rows = append(rows, row)</span>
        }

        <span class="cov5" title="14">return rows, nil</span>
}

// findColumn finds a column index by trying multiple possible names
func (p *KDPParser) findColumn(colMap map[string]int, names ...string) int <span class="cov8" title="90">{
        for _, name := range names </span><span class="cov10" title="175">{
                if idx, ok := colMap[strings.ToLower(name)]; ok </span><span class="cov7" title="46">{
                        return idx
                }</span>
        }
        <span class="cov7" title="44">return -1</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package prompts

import (
        "fmt"
        "strings"
)

// BookNiche represents different book categories
type BookNiche string

const (
        ChildrenBooks BookNiche = "children"
        Puzzles       BookNiche = "puzzles"
        Savings       BookNiche = "savings"
        DialectPuzzles BookNiche = "dialect_puzzles"
)

// IdeaPromptTemplate generates a prompt for content idea generation
func IdeaPromptTemplate(bookTitle, genre, targetAudience string, niche BookNiche, count int) string <span class="cov0" title="0">{
        baseContext := fmt.Sprintf(`Sei un esperto di social media marketing per libri self-published su Amazon KDP.

Il libro: "%s"
Genere: %s
Target: %s

Devi generare %d idee creative per contenuti TikTok/Instagram Reels che promuovano questo libro.`, bookTitle, genre, targetAudience, count)

        var nicheGuidelines string

        switch niche </span>{
        case ChildrenBooks:<span class="cov0" title="0">
                nicheGuidelines = `
LINEE GUIDA per libri per bambini:
- Mostra momenti divertenti di lettura con i bambini
- Behind-the-scenes della creazione delle illustrazioni
- Consigli educativi per genitori
- Tutorial creativi ispirati al libro
- Storie animate delle pagine del libro
- Testimonianze di genitori e bambini`</span>

        case Puzzles:<span class="cov0" title="0">
                nicheGuidelines = `
LINEE GUIDA per libri di enigmistica:
- Sfide e quiz interattivi dal libro
- Time-lapse di risoluzione enigmi
- Curiosit√† e trucchi per enigmisti
- Confronti "prima vs dopo" della mente
- Mini-sfide con premio (engagement)
- Spiegazione di enigmi particolarmente difficili`</span>

        case DialectPuzzles:<span class="cov0" title="0">
                nicheGuidelines = `
LINEE GUIDA per enigmistica in dialetto milanese:
- Parole milanesi dimenticate con spiegazioni divertenti
- Confronto dialetto vs italiano standard
- Quiz su modi di dire milanesi
- Storielle brevi in dialetto
- Nostalgia e tradizioni milanesi
- Coinvolgimento community milanese`</span>

        case Savings:<span class="cov0" title="0">
                nicheGuidelines = `
LINEE GUIDA per libri sul risparmio:
- Tips pratici di risparmio giornaliero
- Testimonianze di successo
- Sfide di risparmio da provare
- Errori comuni da evitare
- Trucchi psicologici per risparmiare
- Confronto spesa prima/dopo consigli del libro`</span>
        }

        <span class="cov0" title="0">categories := `
CATEGORIE di contenuto (distribuisci equamente):
1. EDUCATIONAL: insegna qualcosa di utile
2. ENTERTAINMENT: diverte e intrattiene
3. BTS (Behind-The-Scenes): mostra il processo creativo
4. UGC (User Generated Content): coinvolge gli utenti
5. TREND: cavalca trend attuali di TikTok/Instagram

Per ogni idea, fornisci:
1. Tipo (educational/entertainment/bts/ugc/trend)
2. Titolo accattivante (max 10 parole)
3. Descrizione breve (2-3 frasi)
4. Hook iniziale suggerito
5. CTA finale suggerito
6. Punteggio rilevanza 0-100

Formato risposta (JSON array):
[
  {
    "type": "educational",
    "title": "Titolo idea",
    "description": "Descrizione dettagliata dell'idea",
    "hook": "Hook iniziale per catturare attenzione",
    "cta": "Call-to-action finale",
    "relevance_score": 85
  },
  ...
]`

        return baseContext + "\n" + nicheGuidelines + "\n" + categories</span>
}

// ScriptPromptTemplate generates a prompt for script generation from an idea
func ScriptPromptTemplate(idea, bookTitle, platform string) string <span class="cov0" title="0">{
        platformSpecs := ""

        if platform == "tiktok" </span><span class="cov0" title="0">{
                platformSpecs = `
SPECIFICHE TIKTOK:
- Durata: 15-60 secondi
- Hook: primi 3 secondi CRITICI
- Ritmo: veloce, dinamico
- Formato: verticale 9:16
- Trend: usa musiche popolari
- Hashtag: 3-5 rilevanti + 2-3 di nicchia`
        }</span> else<span class="cov0" title="0"> if platform == "instagram" </span><span class="cov0" title="0">{
                platformSpecs = `
SPECIFICHE INSTAGRAM REELS:
- Durata: 15-90 secondi
- Hook: primi 3 secondi CRITICI
- Ritmo: medio-veloce
- Formato: verticale 9:16
- Audio: trending o originale
- Hashtag: 5-10 misti (popolari + nicchia)`
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`Sei un copywriter esperto di TikTok e Instagram Reels.

Idea da trasformare in script:
"%s"

Libro promosso: "%s"
Platform: %s

%s

Crea uno script completo strutturato cos√¨:

**HOOK (3-5 secondi)**
La frase/domanda che ferma lo scroll. Deve essere:
- Provocatoria o curiosa
- Relazionabile al target
- Chiara e diretta

**CONTENUTO PRINCIPALE (25-45 secondi)**
- Sviluppa l'idea in 3-5 punti chiave
- Linguaggio semplice e diretto
- Usa "tu" per parlare direttamente al viewer
- Include dettagli specifici e concreti

**CTA (5-10 secondi)**
- Invito all'azione chiaro
- Perch√© dovrebbero comprare il libro
- Dove trovarlo (link in bio)

**EXTRA**
- 5-8 hashtag strategici
- Suggerimento musica/audio trending
- Note per il montaggio video

Formato risposta (JSON):
{
  "hook": "Hook text qui",
  "main_content": "Contenuto principale qui (separato in paragrafi)",
  "cta": "CTA text qui",
  "hashtags": ["#tag1", "#tag2", ...],
  "music_suggestion": "Nome traccia/audio trending",
  "video_notes": "Note per editing e montaggio",
  "estimated_length": 45
}`, idea, bookTitle, platform, platformSpecs)</span>
}

// CalculateRelevanceScore calculates a relevance score for an idea
func CalculateRelevanceScore(ideaType, bookGenre string, hasBookReference bool, trendAlignment int) int <span class="cov0" title="0">{
        score := 50 // base score

        // Type alignment with genre
        typeScores := map[string]map[string]int{
                "children": {
                        "educational":   +20,
                        "entertainment": +15,
                        "bts":           +10,
                        "ugc":           +15,
                        "trend":         +10,
                },
                "puzzles": {
                        "educational":   +15,
                        "entertainment": +20,
                        "bts":           +5,
                        "ugc":           +20,
                        "trend":         +15,
                },
                "savings": {
                        "educational":   +25,
                        "entertainment": +10,
                        "bts":           +10,
                        "ugc":           +15,
                        "trend":         +10,
                },
        }

        if genreScores, ok := typeScores[strings.ToLower(bookGenre)]; ok </span><span class="cov0" title="0">{
                if typeScore, ok := genreScores[ideaType]; ok </span><span class="cov0" title="0">{
                        score += typeScore
                }</span>
        }

        // Book reference bonus
        <span class="cov0" title="0">if hasBookReference </span><span class="cov0" title="0">{
                score += 10
        }</span>

        // Trend alignment (0-20)
        <span class="cov0" title="0">score += trendAlignment

        // Cap at 100
        if score &gt; 100 </span><span class="cov0" title="0">{
                score = 100
        }</span>

        <span class="cov0" title="0">return score</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
)

// BooksRepository handles book database operations
type BooksRepository struct {
        config *config.SupabaseConfig
        client *http.Client
}

// NewBooksRepository creates a new books repository
func NewBooksRepository(cfg *config.SupabaseConfig) *BooksRepository <span class="cov0" title="0">{
        return &amp;BooksRepository{
                config: cfg,
                client: &amp;http.Client{},
        }
}</span>

// Create creates a new book
func (r *BooksRepository) Create(input *models.BookInput) (*models.Book, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/books", r.config.URL)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal book: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create book: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create book: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var books []models.Book
        if err := json.Unmarshal(body, &amp;books); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(books) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no book returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;books[0], nil</span>
}

// GetAll retrieves all books
func (r *BooksRepository) GetAll() ([]models.Book, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/books?select=*&amp;order=created_at.desc", r.config.URL)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get books: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get books: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var books []models.Book
        if err := json.Unmarshal(body, &amp;books); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return books, nil</span>
}

// GetByID retrieves a book by ID
func (r *BooksRepository) GetByID(id string) (*models.Book, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/books?id=eq.%s&amp;select=*", r.config.URL, id)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get book: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get book: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var books []models.Book
        if err := json.Unmarshal(body, &amp;books); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(books) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("book not found")
        }</span>

        <span class="cov0" title="0">return &amp;books[0], nil</span>
}

// Update updates a book
func (r *BooksRepository) Update(id string, input *models.BookInput) (*models.Book, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/books?id=eq.%s", r.config.URL, id)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal book: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PATCH", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update book: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update book: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var books []models.Book
        if err := json.Unmarshal(body, &amp;books); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(books) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no book returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;books[0], nil</span>
}

// Delete deletes a book
func (r *BooksRepository) Delete(id string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/books?id=eq.%s", r.config.URL, id)

        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete book: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusNoContent &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to delete book: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
)

// CalendarRepository handles calendar database operations
type CalendarRepository struct {
        config *config.SupabaseConfig
        client *http.Client
}

// NewCalendarRepository creates a new calendar repository
func NewCalendarRepository(cfg *config.SupabaseConfig) *CalendarRepository <span class="cov0" title="0">{
        return &amp;CalendarRepository{
                config: cfg,
                client: &amp;http.Client{},
        }
}</span>

// CreateEntry creates a new calendar entry
func (r *CalendarRepository) CreateEntry(input *models.ContentCalendarInput) (*models.ContentCalendar, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_calendar", r.config.URL)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal entry: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create entry: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create entry: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var entries []models.ContentCalendar
        if err := json.Unmarshal(body, &amp;entries); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no entry returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;entries[0], nil</span>
}

// GetEntries retrieves calendar entries with optional filters
func (r *CalendarRepository) GetEntries(status string, limit int) ([]models.ContentCalendar, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_calendar?select=*&amp;order=scheduled_for.asc", r.config.URL)

        if status != "" </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;status=eq.%s", status)
        }</span>
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;limit=%d", limit)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entries: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entries: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var entries []models.ContentCalendar
        if err := json.Unmarshal(body, &amp;entries); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return entries, nil</span>
}

// UpdateEntryStatus updates the status of a calendar entry
func (r *CalendarRepository) UpdateEntryStatus(id string, status string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_calendar?id=eq.%s", r.config.URL, id)

        data := map[string]string{"status": status}
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal data: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PATCH", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update entry: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to update entry: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteEntry deletes a calendar entry
func (r *CalendarRepository) DeleteEntry(id string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_calendar?id=eq.%s", r.config.URL, id)

        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete entry: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusNoContent &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to delete entry: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
)

// ContentRepository handles content database operations
type ContentRepository struct {
        config *config.SupabaseConfig
        client *http.Client
}

// NewContentRepository creates a new content repository
func NewContentRepository(cfg *config.SupabaseConfig) *ContentRepository <span class="cov0" title="0">{
        return &amp;ContentRepository{
                config: cfg,
                client: &amp;http.Client{},
        }
}</span>

// CreateIdea creates a new content idea
func (r *ContentRepository) CreateIdea(input *models.ContentIdeaInput) (*models.ContentIdea, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_ideas", r.config.URL)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal idea: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create idea: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create idea: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var ideas []models.ContentIdea
        if err := json.Unmarshal(body, &amp;ideas); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ideas) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no idea returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;ideas[0], nil</span>
}

// GetIdeas retrieves content ideas with optional filters
func (r *ContentRepository) GetIdeas(status string, limit int) ([]models.ContentIdea, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_ideas?select=*&amp;order=generated_at.desc", r.config.URL)

        if status != "" </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;status=eq.%s", status)
        }</span>
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;limit=%d", limit)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ideas: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ideas: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var ideas []models.ContentIdea
        if err := json.Unmarshal(body, &amp;ideas); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return ideas, nil</span>
}

// UpdateIdeaStatus updates the status of a content idea
func (r *ContentRepository) UpdateIdeaStatus(id string, status string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_ideas?id=eq.%s", r.config.URL, id)

        data := map[string]string{"status": status}
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal data: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PATCH", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update idea: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to update idea: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateScript creates a new content script
func (r *ContentRepository) CreateScript(input *models.ContentScriptInput) (*models.ContentScript, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_scripts", r.config.URL)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal script: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create script: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create script: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var scripts []models.ContentScript
        if err := json.Unmarshal(body, &amp;scripts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(scripts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no script returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;scripts[0], nil</span>
}

// GetScripts retrieves content scripts
func (r *ContentRepository) GetScripts(limit int) ([]models.ContentScript, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/content_scripts?select=*&amp;order=scripted_at.desc", r.config.URL)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;limit=%d", limit)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get scripts: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get scripts: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var scripts []models.ContentScript
        if err := json.Unmarshal(body, &amp;scripts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return scripts, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
)

// MetricsRepository handles metrics database operations
type MetricsRepository struct {
        config *config.SupabaseConfig
        client *http.Client
}

// NewMetricsRepository creates a new metrics repository
func NewMetricsRepository(cfg *config.SupabaseConfig) *MetricsRepository <span class="cov0" title="0">{
        return &amp;MetricsRepository{
                config: cfg,
                client: &amp;http.Client{},
        }
}</span>

// CreateMetric creates a new post metric
func (r *MetricsRepository) CreateMetric(input *models.PostMetricInput) (*models.PostMetric, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/post_metrics", r.config.URL)

        // Calculate engagement rate
        engagementRate := input.CalculateEngagementRate()

        data := map[string]interface{}{
                "calendar_id":     input.CalendarID,
                "platform":        input.Platform,
                "views":           input.Views,
                "likes":           input.Likes,
                "comments":        input.Comments,
                "shares":          input.Shares,
                "saves":           input.Saves,
                "engagement_rate": engagementRate,
        }

        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal metric: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create metric: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create metric: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var metrics []models.PostMetric
        if err := json.Unmarshal(body, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(metrics) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no metric returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;metrics[0], nil</span>
}

// GetMetrics retrieves metrics with optional filters
func (r *MetricsRepository) GetMetrics(platform string, from, to time.Time) ([]models.PostMetric, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/post_metrics?select=*&amp;order=collected_at.desc", r.config.URL)

        if platform != "" </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;platform=eq.%s", platform)
        }</span>
        <span class="cov0" title="0">if !from.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;collected_at=gte.%s", from.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if !to.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;collected_at=lte.%s", to.Format(time.RFC3339))
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get metrics: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get metrics: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var metrics []models.PostMetric
        if err := json.Unmarshal(body, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return metrics, nil</span>
}

// GetAggregateMetrics retrieves aggregated metrics for a period
func (r *MetricsRepository) GetAggregateMetrics(platform string, from, to time.Time) (*models.AggregateMetrics, error) <span class="cov0" title="0">{
        metrics, err := r.GetMetrics(platform, from, to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(metrics) == 0 </span><span class="cov0" title="0">{
                return &amp;models.AggregateMetrics{}, nil
        }</span>

        <span class="cov0" title="0">agg := &amp;models.AggregateMetrics{
                TotalPosts: len(metrics),
        }

        var totalEngagement float64
        var topEngagement float64
        var topPostID string

        for _, m := range metrics </span><span class="cov0" title="0">{
                agg.TotalViews += m.Views
                agg.TotalLikes += m.Likes
                agg.TotalComments += m.Comments
                agg.TotalShares += m.Shares
                totalEngagement += m.EngagementRate

                if m.EngagementRate &gt; topEngagement </span><span class="cov0" title="0">{
                        topEngagement = m.EngagementRate
                        topPostID = m.CalendarID
                }</span>
        }

        <span class="cov0" title="0">agg.AvgEngagement = totalEngagement / float64(len(metrics))
        agg.TopPost = topPostID
        agg.TopEngagement = topEngagement

        return agg, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package repository

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/gagipress/gagipress-cli/internal/models"
)

// SalesRepository handles sales database operations
type SalesRepository struct {
        config *config.SupabaseConfig
        client *http.Client
}

// NewSalesRepository creates a new sales repository
func NewSalesRepository(cfg *config.SupabaseConfig) *SalesRepository <span class="cov0" title="0">{
        return &amp;SalesRepository{
                config: cfg,
                client: &amp;http.Client{},
        }
}</span>

// CreateSale creates a new book sale record
func (r *SalesRepository) CreateSale(input *models.BookSaleInput) (*models.BookSale, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/book_sales", r.config.URL)

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal sale: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)
        req.Header.Set("Prefer", "return=representation")

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sale: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sale: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var sales []models.BookSale
        if err := json.Unmarshal(body, &amp;sales); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(sales) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no sale returned from API")
        }</span>

        <span class="cov0" title="0">return &amp;sales[0], nil</span>
}

// GetSalesByBook retrieves sales for a specific book
func (r *SalesRepository) GetSalesByBook(bookID string, from, to time.Time) ([]models.BookSale, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/book_sales?book_id=eq.%s&amp;order=sale_date.asc", r.config.URL, bookID)

        if !from.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;sale_date=gte.%s", from.Format("2006-01-02"))
        }</span>
        <span class="cov0" title="0">if !to.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;sale_date=lte.%s", to.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sales: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sales: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var sales []models.BookSale
        if err := json.Unmarshal(body, &amp;sales); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return sales, nil</span>
}

// GetAllSales retrieves all sales
func (r *SalesRepository) GetAllSales(from, to time.Time) ([]models.BookSale, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/rest/v1/book_sales?select=*&amp;order=sale_date.desc", r.config.URL)

        if !from.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;sale_date=gte.%s", from.Format("2006-01-02"))
        }</span>
        <span class="cov0" title="0">if !to.IsZero() </span><span class="cov0" title="0">{
                url += fmt.Sprintf("&amp;sale_date=lte.%s", to.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := r.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = r.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sales: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sales: HTTP %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var sales []models.BookSale
        if err := json.Unmarshal(body, &amp;sales); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return sales, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package scheduler

import (
        "time"
)

// Optimizer handles posting time optimization
type Optimizer struct {
        historicalData map[string][]MetricPoint
}

// MetricPoint represents historical performance data
type MetricPoint struct {
        Hour           int
        DayOfWeek      time.Weekday
        EngagementRate float64
}

// NewOptimizer creates a new posting time optimizer
func NewOptimizer() *Optimizer <span class="cov5" title="7">{
        return &amp;Optimizer{
                historicalData: make(map[string][]MetricPoint),
        }
}</span>

// GetOptimalTimes returns optimal posting times for a period
func (o *Optimizer) GetOptimalTimes(days int, postsPerDay int) []TimeSlot <span class="cov5" title="6">{
        var slots []TimeSlot

        // Start from next day at midnight
        startDate := time.Now().AddDate(0, 0, 1)
        startDate = time.Date(startDate.Year(), startDate.Month(), startDate.Day(), 0, 0, 0, 0, startDate.Location())

        // Default peak times for TikTok/Instagram Reels
        // Based on industry research:
        // - TikTok: 6-10am, 7-11pm
        // - Instagram: 11am-2pm, 7-9pm
        peakHours := []int{7, 12, 19, 21}

        for day := 0; day &lt; days; day++ </span><span class="cov8" title="26">{
                currentDate := startDate.AddDate(0, 0, day)

                // Distribute posts throughout the day using peak hours
                for i := 0; i &lt; postsPerDay; i++ </span><span class="cov10" title="44">{
                        hourIndex := i % len(peakHours)
                        hour := peakHours[hourIndex]

                        // Add some variation to avoid exact same time every day
                        minuteVariation := (day * 7) % 60 // 0-60 minutes variation

                        postTime := time.Date(
                                currentDate.Year(),
                                currentDate.Month(),
                                currentDate.Day(),
                                hour,
                                minuteVariation,
                                0,
                                0,
                                currentDate.Location(),
                        )

                        // Determine platform based on time
                        platform := "tiktok"
                        if hour &gt;= 11 &amp;&amp; hour &lt;= 14 </span><span class="cov7" title="16">{
                                platform = "instagram" // Lunch time better for Instagram
                        }</span>

                        <span class="cov10" title="44">slots = append(slots, TimeSlot{
                                Time:     postTime,
                                Platform: platform,
                                Type:     "scheduled",
                        })</span>
                }
        }

        <span class="cov5" title="6">return slots</span>
}

// AnalyzeHistoricalData analyzes past performance to optimize times
func (o *Optimizer) AnalyzeHistoricalData(platform string, metrics []MetricPoint) <span class="cov1" title="1">{
        o.historicalData[platform] = metrics

        // In a real implementation, this would:
        // 1. Group metrics by hour and day of week
        // 2. Calculate average engagement for each time slot
        // 3. Identify top-performing times
        // 4. Return personalized peak times
}</span>

// GetPeakTimes returns the best times based on historical data
func (o *Optimizer) GetPeakTimes(platform string, count int) []time.Time <span class="cov3" title="3">{
        // If we have historical data, use it
        if data, ok := o.historicalData[platform]; ok &amp;&amp; len(data) &gt; 0 </span><span class="cov0" title="0">{
                // Sort by engagement rate
                // Return top N times
                _ = data // Use historical data in real implementation
        }</span>

        // Default peak times
        <span class="cov3" title="3">var times []time.Time
        peakHours := []int{7, 12, 19, 21}

        now := time.Now()
        for i := 0; i &lt; count; i++ </span><span class="cov7" title="14">{
                hour := peakHours[i%len(peakHours)]
                t := time.Date(now.Year(), now.Month(), now.Day(), hour, 0, 0, 0, now.Location())
                times = append(times, t)
        }</span>

        <span class="cov3" title="3">return times</span>
}

// ContentMixStrategy determines how to balance different content types
type ContentMixStrategy struct {
        Educational   float64 // 0.0 - 1.0
        Entertainment float64
        BTS           float64
        UGC           float64
        Trend         float64
}

// DefaultMixStrategy returns a balanced content mix
func DefaultMixStrategy() ContentMixStrategy <span class="cov1" title="1">{
        return ContentMixStrategy{
                Educational:   0.25,
                Entertainment: 0.25,
                BTS:           0.15,
                UGC:           0.20,
                Trend:         0.15,
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package scheduler

import (
        "fmt"
        "sort"
        "time"

        "github.com/gagipress/gagipress-cli/internal/models"
        "github.com/gagipress/gagipress-cli/internal/repository"
)

// Planner handles content calendar planning
type Planner struct {
        contentRepo *repository.ContentRepository
        optimizer   *Optimizer
}

// NewPlanner creates a new calendar planner
func NewPlanner(contentRepo *repository.ContentRepository) *Planner <span class="cov0" title="0">{
        return &amp;Planner{
                contentRepo: contentRepo,
                optimizer:   NewOptimizer(),
        }
}</span>

// PlanWeek creates a weekly content plan
func (p *Planner) PlanWeek(days int, postsPerDay int) ([]*models.ContentCalendarInput, error) <span class="cov0" title="0">{
        // Get available scripts (from scripted ideas)
        scripts, err := p.contentRepo.GetScripts(0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get scripts: %w", err)
        }</span>

        <span class="cov0" title="0">if len(scripts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no scripts available for planning")
        }</span>

        <span class="cov0" title="0">totalPosts := days * postsPerDay
        if len(scripts) &lt; totalPosts </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not enough scripts: need %d, have %d", totalPosts, len(scripts))
        }</span>

        // Group scripts by type for balanced distribution
        <span class="cov0" title="0">scriptsByType := make(map[string][]models.ContentScript)
        for _, script := range scripts </span><span class="cov0" title="0">{
                // We need to get the idea to know the type
                // For now, we'll just use the scripts directly
                scriptsByType["mixed"] = append(scriptsByType["mixed"], script)
        }</span>

        // Get optimal posting times
        <span class="cov0" title="0">postingTimes := p.optimizer.GetOptimalTimes(days, postsPerDay)

        // Create calendar entries
        var calendar []*models.ContentCalendarInput
        scriptIndex := 0

        for _, slot := range postingTimes </span><span class="cov0" title="0">{
                if scriptIndex &gt;= len(scripts) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">script := scripts[scriptIndex]

                // Determine platform based on script characteristics
                platform := "tiktok"
                if script.EstimatedLength &gt; 60 </span><span class="cov0" title="0">{
                        platform = "instagram" // Longer content for Instagram
                }</span>

                <span class="cov0" title="0">entry := &amp;models.ContentCalendarInput{
                        ScriptID:     &amp;script.ID,
                        ScheduledFor: slot.Time,
                        Platform:     platform,
                }

                calendar = append(calendar, entry)
                scriptIndex++

                if len(calendar) &gt;= totalPosts </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return calendar, nil</span>
}

// TimeSlot represents a scheduled time slot
type TimeSlot struct {
        Time     time.Time
        Platform string
        Type     string
}

// BalanceContentMix ensures diverse content types in the calendar
func (p *Planner) BalanceContentMix(scripts []models.ContentScript) []models.ContentScript <span class="cov1" title="1">{
        // Sort by ID for now (deterministic)
        sort.Slice(scripts, func(i, j int) bool </span><span class="cov10" title="3">{
                return scripts[i].ID &lt; scripts[j].ID
        }</span>)

        // In a real implementation, this would:
        // 1. Group by content type (educational, entertainment, etc.)
        // 2. Ensure balanced distribution
        // 3. Avoid same type back-to-back
        // 4. Rotate between books

        <span class="cov1" title="1">return scripts</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package social

import (
        "fmt"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
)

// InstagramClient handles Instagram Graph API interactions
type InstagramClient struct {
        accessToken string
        accountID   string
}

// Post represents an Instagram post
type Post struct {
        ID           string    `json:"id"`
        Caption      string    `json:"caption"`
        MediaType    string    `json:"media_type"` // IMAGE, VIDEO, CAROUSEL_ALBUM
        MediaURL     string    `json:"media_url"`
        Permalink    string    `json:"permalink"`
        Timestamp    time.Time `json:"timestamp"`
        LikesCount   int       `json:"like_count"`
        CommentsCount int      `json:"comments_count"`
}

// Metrics represents post performance metrics
type Metrics struct {
        Impressions int `json:"impressions"`
        Reach       int `json:"reach"`
        Engagement  int `json:"engagement"`
        Saves       int `json:"saves"`
        Shares      int `json:"shares"`
}

// NewInstagramClient creates a new Instagram API client
func NewInstagramClient(cfg *config.InstagramConfig) *InstagramClient <span class="cov0" title="0">{
        return &amp;InstagramClient{
                accessToken: cfg.AccessToken,
                accountID:   cfg.AccountID,
        }
}</span>

// PublishPost publishes a post to Instagram
// TODO: Implement actual API call
func (c *InstagramClient) PublishPost(caption string, mediaURL string) (*Post, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: Instagram publishing requires OAuth flow setup")
}</span>

// GetPostMetrics retrieves metrics for a specific post
// TODO: Implement actual API call
func (c *InstagramClient) GetPostMetrics(postID string) (*Metrics, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: requires Instagram Graph API access")
}</span>

// GetRecentPosts retrieves recent posts
// TODO: Implement actual API call
func (c *InstagramClient) GetRecentPosts(limit int) ([]Post, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: requires Instagram Graph API access")
}</span>

// TestConnection tests the Instagram API connection
func (c *InstagramClient) TestConnection() error <span class="cov0" title="0">{
        if c.accessToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Instagram access token not configured")
        }</span>
        // TODO: Implement actual connection test with API
        <span class="cov0" title="0">return fmt.Errorf("not implemented: OAuth flow required first")</span>
}

// Note: OAuth flow will be implemented in Week 3
// Requires:
// 1. Facebook App setup
// 2. Instagram Business Account
// 3. OAuth redirect handling
// 4. Token refresh mechanism
</pre>
		
		<pre class="file" id="file53" style="display: none">package social

import (
        "fmt"
        "time"

        "github.com/gagipress/gagipress-cli/internal/config"
)

// TikTokClient handles TikTok API interactions
type TikTokClient struct {
        accessToken string
        accountID   string
}

// TikTokPost represents a TikTok post
type TikTokPost struct {
        ID            string    `json:"id"`
        VideoID       string    `json:"video_id"`
        Caption       string    `json:"caption"`
        ShareURL      string    `json:"share_url"`
        CreatedAt     time.Time `json:"create_time"`
        ViewsCount    int       `json:"view_count"`
        LikesCount    int       `json:"like_count"`
        CommentsCount int       `json:"comment_count"`
        SharesCount   int       `json:"share_count"`
}

// TikTokMetrics represents TikTok post metrics
type TikTokMetrics struct {
        VideoViews        int     `json:"video_views"`
        ProfileViews      int     `json:"profile_views"`
        Likes             int     `json:"likes"`
        Comments          int     `json:"comments"`
        Shares            int     `json:"shares"`
        EngagementRate    float64 `json:"engagement_rate"`
        AverageWatchTime  float64 `json:"average_watch_time"`
        TotalWatchTime    int     `json:"total_watch_time"`
}

// NewTikTokClient creates a new TikTok API client
func NewTikTokClient(cfg *config.TikTokConfig) *TikTokClient <span class="cov0" title="0">{
        return &amp;TikTokClient{
                accessToken: cfg.AccessToken,
                accountID:   cfg.AccountID,
        }
}</span>

// PublishVideo publishes a video to TikTok
// TODO: Implement actual API call
func (c *TikTokClient) PublishVideo(caption string, videoURL string, hashtags []string) (*TikTokPost, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: TikTok publishing requires OAuth flow setup")
}</span>

// GetVideoMetrics retrieves metrics for a specific video
// TODO: Implement actual API call
func (c *TikTokClient) GetVideoMetrics(videoID string) (*TikTokMetrics, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: requires TikTok API access")
}</span>

// GetRecentVideos retrieves recent videos
// TODO: Implement actual API call
func (c *TikTokClient) GetRecentVideos(limit int) ([]TikTokPost, error) <span class="cov0" title="0">{
        // Placeholder implementation
        return nil, fmt.Errorf("not implemented: requires TikTok API access")
}</span>

// TestConnection tests the TikTok API connection
func (c *TikTokClient) TestConnection() error <span class="cov0" title="0">{
        if c.accessToken == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("TikTok access token not configured")
        }</span>
        // TODO: Implement actual connection test with API
        <span class="cov0" title="0">return fmt.Errorf("not implemented: OAuth flow required first")</span>
}

// Note: OAuth flow will be implemented in Week 3
// Requires:
// 1. TikTok Developer Account
// 2. App creation in TikTok Developer Portal
// 3. OAuth redirect handling
// 4. Token refresh mechanism
// 5. Video upload endpoint configuration
</pre>
		
		<pre class="file" id="file54" style="display: none">package supabase

import (
        "fmt"

        "github.com/gagipress/gagipress-cli/internal/config"
        "github.com/supabase-community/supabase-go"
)

// Client wraps the Supabase client with our configuration
type Client struct {
        *supabase.Client
        config *config.SupabaseConfig
}

// NewClient creates a new Supabase client from configuration
func NewClient(cfg *config.SupabaseConfig) (*Client, error) <span class="cov0" title="0">{
        if cfg.URL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("supabase URL is required")
        }</span>
        <span class="cov0" title="0">if cfg.AnonKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("supabase anon key is required")
        }</span>

        // Use service key if available, otherwise anon key
        <span class="cov0" title="0">apiKey := cfg.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = cfg.AnonKey
        }</span>

        <span class="cov0" title="0">client, err := supabase.NewClient(cfg.URL, apiKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create supabase client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                Client: client,
                config: cfg,
        }, nil</span>
}

// TestConnection verifies the connection to Supabase
func (c *Client) TestConnection() error <span class="cov0" title="0">{
        // Simple health check - try to query a system table
        // For now, just verify the client was created successfully
        if c.Client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client is nil")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package supabase

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
)

// Migration represents a database migration
type Migration struct {
        Version     int
        Description string
        SQL         string
        FilePath    string
}

// LoadMigrations loads all migration files from the migrations directory
func LoadMigrations(migrationsDir string) ([]Migration, error) <span class="cov0" title="0">{
        var migrations []Migration

        files, err := os.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read migrations directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDir() || !strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filePath := filepath.Join(migrationsDir, file.Name())
                content, err := os.ReadFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read migration file %s: %w", file.Name(), err)
                }</span>

                // Extract version from filename (e.g., "001_initial_schema.sql" -&gt; 1)
                <span class="cov0" title="0">var version int
                var description string
                parts := strings.SplitN(file.Name(), "_", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        fmt.Sscanf(parts[0], "%d", &amp;version)
                        description = strings.TrimSuffix(parts[1], ".sql")
                        description = strings.ReplaceAll(description, "_", " ")
                }</span>

                <span class="cov0" title="0">migrations = append(migrations, Migration{
                        Version:     version,
                        Description: description,
                        SQL:         string(content),
                        FilePath:    filePath,
                })</span>
        }

        <span class="cov0" title="0">return migrations, nil</span>
}

// RunMigration executes a migration SQL using Supabase REST API
func (c *Client) RunMigration(migration Migration) error <span class="cov0" title="0">{
        // Supabase doesn't have a direct "execute SQL" endpoint in the REST API
        // We need to use the PostgREST admin API or pg_net extension
        // For now, we'll use a workaround: execute via HTTP POST to /rest/v1/rpc

        // Split SQL into individual statements
        statements := splitSQLStatements(migration.SQL)

        for i, stmt := range statements </span><span class="cov0" title="0">{
                stmt = strings.TrimSpace(stmt)
                if stmt == "" || strings.HasPrefix(stmt, "--") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Execute each statement via raw SQL
                <span class="cov0" title="0">if err := c.executeRawSQL(stmt); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute statement %d: %w\nStatement: %s", i+1, err, stmt)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeRawSQL executes raw SQL using Supabase's PostgREST
func (c *Client) executeRawSQL(sql string) error <span class="cov0" title="0">{
        // Build request URL
        url := fmt.Sprintf("%s/rest/v1/rpc/exec_sql", c.config.URL)

        // Prepare request body
        body := map[string]interface{}{
                "sql": sql,
        }
        bodyBytes, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">apiKey := c.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = c.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        // Execute request
        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("SQL execution failed (status %d): %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// splitSQLStatements splits a SQL file into individual statements
func splitSQLStatements(sql string) []string <span class="cov0" title="0">{
        // Simple split by semicolon (not perfect but works for most cases)
        // This doesn't handle complex cases like semicolons in strings or function bodies
        statements := strings.Split(sql, ";")

        var result []string
        var buffer strings.Builder
        inFunctionOrBlock := false

        for _, stmt := range statements </span><span class="cov0" title="0">{
                stmt = strings.TrimSpace(stmt)

                // Check if we're entering a function/procedure/block
                lowerStmt := strings.ToLower(stmt)
                if strings.Contains(lowerStmt, "create function") ||
                        strings.Contains(lowerStmt, "create or replace function") ||
                        strings.Contains(lowerStmt, "create procedure") ||
                        strings.Contains(lowerStmt, "do $$") </span><span class="cov0" title="0">{
                        inFunctionOrBlock = true
                }</span>

                // Add to buffer
                <span class="cov0" title="0">if buffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                        buffer.WriteString("; ")
                }</span>
                <span class="cov0" title="0">buffer.WriteString(stmt)

                // Check if we're closing a function/procedure/block
                if inFunctionOrBlock </span><span class="cov0" title="0">{
                        if strings.Contains(lowerStmt, "language plpgsql") ||
                                strings.Contains(lowerStmt, "$$") </span><span class="cov0" title="0">{
                                inFunctionOrBlock = false
                                result = append(result, buffer.String())
                                buffer.Reset()
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Regular statement
                        if stmt != "" </span><span class="cov0" title="0">{
                                result = append(result, buffer.String())
                                buffer.Reset()
                        }</span>
                }
        }

        // Add any remaining buffer content
        <span class="cov0" title="0">if buffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                result = append(result, buffer.String())
        }</span>

        <span class="cov0" title="0">return result</span>
}

// GetAppliedVersion checks which migrations have been applied
func (c *Client) GetAppliedVersion() (int, error) <span class="cov0" title="0">{
        // Try to query the schema_version table
        // If it doesn't exist, we'll get an error and return 0

        url := fmt.Sprintf("%s/rest/v1/schema_version?select=version&amp;order=version.desc&amp;limit=1", c.config.URL)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">apiKey := c.config.ServiceKey
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = c.config.AnonKey
        }</span>

        <span class="cov0" title="0">req.Header.Set("apikey", apiKey)
        req.Header.Set("Authorization", "Bearer "+apiKey)

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil // Table might not exist
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 404 || resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return 0, nil // Table doesn't exist yet
        }</span>

        <span class="cov0" title="0">var result []map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">version, ok := result[0]["version"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid version type")
        }</span>

        <span class="cov0" title="0">return int(version), nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package testutil

import (
        "testing"
)

// AssertNoError fails the test if err is not nil
func AssertNoError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("unexpected error: %v", err)
        }</span>
}

// AssertError fails the test if err is nil
func AssertError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("expected error but got nil")
        }</span>
}

// AssertEqual fails if actual != expected
func AssertEqual(t *testing.T, expected, actual interface{}) <span class="cov0" title="0">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                t.Fatalf("expected %v, got %v", expected, actual)
        }</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package ui

import (
        "fmt"
        "time"
)

// Spinner provides visual feedback for long operations
type Spinner struct {
        message string
        done    chan bool
}

// NewSpinner creates a new spinner with message
func NewSpinner(message string) *Spinner <span class="cov0" title="0">{
        return &amp;Spinner{
                message: message,
                done:    make(chan bool),
        }
}</span>

// Start begins the spinner animation
func (s *Spinner) Start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                frames := []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"}
                i := 0
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                fmt.Printf("\r%s %s", frames[i], s.message)
                                i = (i + 1) % len(frames)
                                time.Sleep(100 * time.Millisecond)</span>
                        }
                }
        }()
}

// Stop stops the spinner and clears the line
func (s *Spinner) Stop() <span class="cov0" title="0">{
        s.done &lt;- true
        fmt.Print("\r\033[K") // Clear line
}</span>

// Success shows success message
func Success(message string) <span class="cov0" title="0">{
        fmt.Printf("‚úì %s\n", message)
}</span>

// Error shows error message
func Error(message string) <span class="cov0" title="0">{
        fmt.Printf("‚úó %s\n", message)
}</span>

// Info shows info message
func Info(message string) <span class="cov0" title="0">{
        fmt.Printf("‚Ñπ %s\n", message)
}</span>

// Warning shows warning message
func Warning(message string) <span class="cov0" title="0">{
        fmt.Printf("‚ö† %s\n", message)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
